<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Shell Field Guide</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Raimon Grau" />
<meta name="keywords" content="bash zsh shell" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Shell Field Guide</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org0d0b8d9">1. Introduction</a></li>
<li><a href="#org5266eeb">2. Which Shell?</a></li>
<li><a href="#org07fe899">3. Level</a></li>
<li><a href="#org43d4606">4. Patterns</a>
<ul>
<li><a href="#org185a551">4.1. Use Shellcheck</a></li>
<li><a href="#org414ff22">4.2. Overview</a></li>
<li><a href="#orgc498a84">4.3. Booleans and Conditionals</a></li>
<li><a href="#org0b623d4">4.4. Arrays</a></li>
<li><a href="#org1c6866d">4.5. Slurping arrays</a></li>
<li><a href="#orgde4815b">4.6. Functions</a></li>
<li><a href="#orgc1c021f">4.7. Variables</a></li>
<li><a href="#orgbd63e27">4.8. Variable Expansions</a></li>
<li><a href="#org5ee6fa6">4.9. Interpolation</a></li>
<li><a href="#orgc6606fa">4.10. dispatch functions using args</a></li>
<li><a href="#org203d91b">4.11. command_not_found_handle</a></li>
<li><a href="#org1809b8b">4.12. Return Values for Conditionals</a></li>
<li><a href="#orgd05d399">4.13. Do work on loop conditions</a></li>
<li><a href="#org1c808b0">4.14. One Branch Conditionals</a></li>
<li><a href="#org1bfec80">4.15. pushd/popd</a></li>
<li><a href="#org05be41a">4.16. wrap functions</a></li>
<li><a href="#org1615023">4.17. use [[</a></li>
<li><a href="#org3fb36bf">4.18. eval?</a></li>
<li><a href="#orgb370f4f">4.19. pass commands around</a></li>
<li><a href="#org4251c9e">4.20. The Toplevel Is Hopeless</a></li>
<li><a href="#org33c329c">4.21. Check your deps</a></li>
<li><a href="#org8a8f4d4">4.22. source files</a></li>
<li><a href="#orgeefc21f">4.23. Use Scripts as a Libs</a></li>
<li><a href="#org4db8a8b">4.24. Tmpfiles Everywhere</a></li>
<li><a href="#orga5e58fd">4.25. Cleanup tasks with trap</a></li>
<li><a href="#orgf29c4d3">4.26. array of callbacks on_exit</a></li>
<li><a href="#org33e60c3">4.27. stacktrace on error</a></li>
<li><a href="#org82782bb">4.28. Dots and colons allowed in function names!</a></li>
<li><a href="#org008017a">4.29. make steps of the process as composable as possible by using "$@"</a></li>
<li><a href="#org6af5998">4.30. do_times/foreach_*</a></li>
<li><a href="#org98d93c4">4.31. &lt;(foo) and &gt;(foo)</a></li>
<li><a href="#org46ae66c">4.32. Use xargs</a></li>
<li><a href="#org714d83e">4.33. change loops for "mapping/reducing" functions</a>
<ul>
<li><a href="#org5922342">4.33.1. find</a></li>
<li><a href="#org9817d6e">4.33.2. grep -Fvf</a></li>
</ul>
</li>
<li><a href="#orgcb38cff">4.34. pass flags as a splatted array</a></li>
<li><a href="#org6e9c1ea">4.35. inherit_errexit</a></li>
<li><a href="#org3863d9a">4.36. GNU Parallel</a></li>
<li><a href="#org00292fd">4.37. HEREDOCS</a></li>
</ul>
</li>
<li><a href="#orge306d07">5. Interactive</a>
<ul>
<li><a href="#orgd1af760">5.1. Save your small scripts</a></li>
<li><a href="#org5e6e96b">5.2. Increased Interactivity</a></li>
<li><a href="#org962892c">5.3. Aliases</a></li>
<li><a href="#org6020ef7">5.4. functions can generate aliases</a></li>
<li><a href="#orgfe481dc">5.5. Override (advise?) common functions</a></li>
<li><a href="#org94434da">5.6. Faster iteration on pipes</a></li>
</ul>
</li>
<li><a href="#orgf94e35c">6. Debugging</a>
<ul>
<li><a href="#orgf7ff040">6.1. adding <code>bash</code> to a script to debug</a></li>
<li><a href="#orgfc8aa1e">6.2. DRY_RUN</a></li>
<li><a href="#orgfe97a65">6.3. Cheap debugging flag</a></li>
<li><a href="#orge0b214e">6.4. explore a pipe with tee &gt;(some_command) |</a></li>
<li><a href="#org259caa9">6.5. tee+sudo</a></li>
<li><a href="#org2e45843">6.6. quoting</a></li>
</ul>
</li>
<li><a href="#orgd4fa533">7. zsh-only</a>
<ul>
<li><a href="#orge590cc8">7.1. Word spliting</a></li>
<li><a href="#orgac80f99">7.2. globbing</a></li>
<li><a href="#org1a119a3">7.3. Some global aliases:</a></li>
<li><a href="#orgd384428">7.4. Autocomplete</a></li>
<li><a href="#org1c2c1fa">7.5. Create helpers and generate global aliases automagically</a></li>
<li><a href="#org2533bc9">7.6. suffix aliases don't have to match a filename</a></li>
<li><a href="#org51fd6da">7.7. noglob</a></li>
<li><a href="#orgae915f4">7.8. make noglob 'transparent' to bash</a></li>
<li><a href="#orgc09a3f5">7.9. glob nested expansion</a></li>
<li><a href="#org627863e">7.10. Some extra shortcuts for nice things</a></li>
<li><a href="#org99781f2">7.11. =()</a></li>
</ul>
</li>
<li><a href="#orga9dc7f7">8. <span class="todo TODO">TODO</span> patterns</a>
<ul>
<li><a href="#org96b5722">8.1. just use cat/netcat/pipes with &lt;()</a>
<ul>
<li><a href="#orge4166c6">8.1.1. what's the unifying theory behind all that?</a></li>
</ul>
</li>
<li><a href="#orgc5c31a8">8.2. redirects &amp; streams</a></li>
<li><a href="#org71610e0">8.3. The $0 pattern</a></li>
<li><a href="#orgec2a1e4">8.4. use git staging area to diff outputs of commands</a></li>
<li><a href="#org451fd08">8.5. coprocs</a></li>
</ul>
</li>
<li><a href="#orga3eb7c8">9. links</a></li>
<li><a href="#org7a15a5c">10. From shell to lisp and everything in between</a></li>
<li><a href="#org735dc96">11. Credits</a></li>
</ul>
</div>
</div>

<div id="outline-container-org0d0b8d9" class="outline-2">
<h2 id="org0d0b8d9"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
This booklet is intended to be a catalog of tricks and techniques
you may want to use if you're doing some sort of complex
scripting. Some are just useful, some are more playful, and might
not have such direct impact in your day-to-day life. Some are pure
entertainment. You'll have to judge by yourself which things belong
to which category. I'll try to keep the rethoric to the minimum to
maximize signal/noise.
</p>

<p>
The git repo is at
<a href="https://github.com/kidd/scripting-field-guide/">https://github.com/kidd/scripting-field-guide/</a>. Any feedback is
greatly appreciated. Keep in mind this is not any kind of official
doc. I just write MY current "state of the art" and I'll be updating
the contents with useful stuff I find or discover, that are not
widely explained in usual manuals/wikis.
</p>

<p>
You probably have some amount of sh/bash/zsh in your stack that
probably started as 1 off scripts, and probably later on started
growing and being copypasted everywhere in your pipelines, or your
coworkers use for their own use (with some variations), etc. Those
scripts are very difficult to kill and they have a very high
mutation rate.
</p>
</div>
</div>
<div id="outline-container-org5266eeb" class="outline-2">
<h2 id="org5266eeb"><span class="section-number-2">2</span> Which Shell?</h2>
<div class="outline-text-2" id="text-2">
<p>
No matter if you use Linux, Mac, or Windows, you should be living
most of the time in a shell to enjoy the content shown here. Some
value comes from the automated scripts, and some comes from the
daily usage and refinement of your helper functions, aliases,
etc. in interactive mode.
</p>

<p>
In general the examples here are ment to run in Bash or Zsh, which
are compatible for the most part.
</p>
</div>
</div>
<div id="outline-container-org07fe899" class="outline-2">
<h2 id="org07fe899"><span class="section-number-2">3</span> Level</h2>
<div class="outline-text-2" id="text-3">
<p>
These examples are based on non-trivial real world code I've written
that I haven't seen applied in many places over the net. A few of
the snippets are stolen from public repos I find interesting and
also, important scripting stuff might be missing if I don't feel I
have anything to add to the generally available info around.
</p>
</div>
</div>
<div id="outline-container-org43d4606" class="outline-2">
<h2 id="org43d4606"><span class="section-number-2">4</span> Patterns</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org185a551" class="outline-3">
<h3 id="org185a551"><span class="section-number-3">4.1</span> Use Shellcheck</h3>
<div class="outline-text-3" id="text-4-1">
<p>
First, let's get that out of the way. This is low hanging
fruit. And you will get the most of this booklet by following it.
</p>

<p>
A lot of the most common errors we usually make are well known
ones. And in fact, we all usually fail in similar ways. Bash is
known for being error prone when dealing with testing variable
values, string operations, or flaky subshells and pipes.
</p>

<p>
Installing <a href="https://www.shellcheck.net/">shellcheck</a> will flag you many of those ticking bombs.
</p>

<p>
No matter which editor you are using, but you should be able to
install a plugin to do automatic checks while you're editing.
</p>

<p>
In emacs' case, the package is called <a href="https://github.com/federicotdn/flymake-shellcheck">flymake-shellcheck</a>, and a
quick configuration for it is:
</p>

<div class="org-src-container">
<pre class="src src-elisp">(use-package flymake-shellcheck
  <span style="font-weight: bold;">:ensure</span> t
  <span style="font-weight: bold;">:commands</span> flymake-shellcheck-load
  <span style="font-weight: bold;">:init</span>
  (add-hook 'sh-mode-hook 'flymake-shellcheck-load))
</pre>
</div>

<p>
Shellcheck is available on most distros, so it's just an <code>apt</code>,
<code>brew</code>, or <code>nix-env</code> away.
</p>
</div>
</div>

<div id="outline-container-org414ff22" class="outline-3">
<h3 id="org414ff22"><span class="section-number-3">4.2</span> Overview</h3>
<div class="outline-text-3" id="text-4-2">
<p>
In this section, we're covering the parts of the basics that are
not so basic after all, or that are more unique in shellscripting
languages.
</p>
</div>
</div>

<div id="outline-container-orgc498a84" class="outline-3">
<h3 id="orgc498a84"><span class="section-number-3">4.3</span> Booleans and Conditionals</h3>
<div class="outline-text-3" id="text-4-3">
<p>
In any shell, <code>foo &amp;&amp; bar</code> will execute <code>bar</code> only if <code>foo</code>
succeeded. That means that <code>foo</code> returned 0. That means that to &amp;&amp;
(which you read like "and"), 0 is true. so yes. 0 is true, and
other values are false.
</p>
</div>
</div>

<div id="outline-container-org0b623d4" class="outline-3">
<h3 id="org0b623d4"><span class="section-number-3">4.4</span> Arrays</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Ordered list of things.
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;">foo</span>=(<span style="font-style: italic;">"ls"</span> <span style="font-style: italic;">"/tmp/"</span>)

<span style="font-weight: bold;">echo</span> ${<span style="font-weight: bold; font-style: italic;">foo</span>[-2]}
<span style="font-weight: bold;">echo</span> ${<span style="font-weight: bold; font-style: italic;">foo</span>[-1]}
<span style="font-weight: bold;">echo</span> ${<span style="font-weight: bold; font-style: italic;">foo</span>[0]}
<span style="font-weight: bold;">echo</span> ${<span style="font-weight: bold; font-style: italic;">foo</span>[1]}
<span style="font-weight: bold;">echo</span> ${<span style="font-weight: bold; font-style: italic;">foo</span>[2]}

<span style="font-weight: bold;">for</span> i<span style="font-weight: bold;"> in</span> <span style="font-style: italic;">"${foo[@]}"</span>; <span style="font-weight: bold;">do</span>
  <span style="font-weight: bold;">echo</span> $<span style="font-weight: bold; font-style: italic;">i</span>
<span style="font-weight: bold;">done</span>

$<span style="font-weight: bold; font-style: italic;">foo</span>
${<span style="font-weight: bold; font-style: italic;">foo</span>[*]}
${<span style="font-weight: bold; font-style: italic;">foo</span>[@]}
<span style="font-weight: bold;">echo</span> ${#<span style="font-weight: bold; font-style: italic;">foo</span>[*]}
<span style="font-weight: bold;">echo</span> ${#<span style="font-weight: bold; font-style: italic;">foo</span>[@]}
</pre>
</div>

<p>
Are <code>*</code> and <code>@</code> equal? <a href="https://stackoverflow.com/questions/2761723/what-is-the-difference-between-and-in-shell-scripts">nope</a>.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-style: italic;">"${foo[@]}"</span>
<span style="font-style: italic;">"${foo[*]}"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org1c6866d" class="outline-3">
<h3 id="org1c6866d"><span class="section-number-3">4.5</span> Slurping arrays</h3>
<div class="outline-text-3" id="text-4-5">
<p>
A nice way to read a bunch of elements from one go is to use
<code>readarray</code>.
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">parse_args</span>() {
  [[ $<span style="font-weight: bold; font-style: italic;">#</span> -eq 0 ]] &amp;&amp; die <span style="font-style: italic;">"Usage: $0 &lt;version&gt;"</span>
  <span style="font-weight: bold; font-style: italic;">version</span>=<span style="font-style: italic;">"$1"</span>
  local <span style="font-weight: bold; font-style: italic;">version_split</span>=$(<span style="font-weight: bold;">echo</span> $<span style="font-weight: bold; font-style: italic;">version</span> | tr <span style="font-style: italic;">'.'</span> <span style="font-style: italic;">'\n'</span>)
  readarray -t version_array &lt;&lt;&lt; <span style="font-style: italic;">"$version_split"</span>

  <span style="font-weight: bold;">if</span> [[ -z ${<span style="font-weight: bold; font-style: italic;">version_array</span>[3]} ]]; <span style="font-weight: bold;">then</span>
    die <span style="font-style: italic;">"not enough version numbers"</span>
  <span style="font-weight: bold;">fi</span>
}
</pre>
</div>

<p>
Even nicer would be to use IFS so we'd be able to split in one go.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;">IFS</span>=. read -a ver &lt;&lt;&lt;<span style="font-style: italic;">"1.23.1.0"</span>
<span style="font-weight: bold;">echo</span> ${<span style="font-weight: bold; font-style: italic;">ver</span>[0]}
<span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"next/${ver[0]}.${ver[1]}.x.x"</span>
</pre>
</div>

<p>
Or, use it in a destructuring fashion:
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">get_nix_version_parts</span>(){
  local major minor patch
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">shellcheck disable=SC2034,SC2162</span>
  <span style="font-weight: bold; font-style: italic;">IFS</span>=<span style="font-style: italic;">"."</span> read major minor patch &lt; &lt;(get_nix_version)
  local -p
}

$ get_nix_version_parts
<span style="font-weight: bold; font-style: italic;">major</span>=2
<span style="font-weight: bold; font-style: italic;">minor</span>=3
<span style="font-weight: bold; font-style: italic;">patch</span>=4
</pre>
</div>
<p>
<a href="https://news.ycombinator.com/item?id=24408318">https://news.ycombinator.com/item?id=24408318</a>
</p>
</div>
</div>

<div id="outline-container-orgde4815b" class="outline-3">
<h3 id="orgde4815b"><span class="section-number-3">4.6</span> Functions</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Functions are functions. They receive arguments, and they return a
value.
</p>

<p>
The special thing about functions in shell is that they also can use
the file descriptors of the process. That means that they "inherit"
STDIN, STDOUT, STDERR (and maybe more).
</p>

<p>
Use them.
</p>

<p>
Another point is that function names can be passed as parameters,
because they are passed as strings, but you can call them inside as
functions again.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">f</span>() {
  $<span style="font-weight: bold; font-style: italic;">1</span> hi
}

f echo
f touch <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">will create a file 'hi'</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc1c021f" class="outline-3">
<h3 id="orgc1c021f"><span class="section-number-3">4.7</span> Variables</h3>
<div class="outline-text-3" id="text-4-7">
<p>
By default variables are global, to a file. No matter if you assign
them for the first time inside a function, or at the top level.
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;">foo</span>=3
<span style="font-weight: bold; font-style: italic;">bar</span>=$<span style="font-weight: bold; font-style: italic;">foo</span>
<span style="font-weight: bold;">f</span>() {
  <span style="font-weight: bold;">echo</span> $<span style="font-weight: bold; font-style: italic;">bar</span>
}
f
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">f</span>() {
  <span style="font-weight: bold; font-style: italic;">bar</span>=1
}
f
<span style="font-weight: bold;">echo</span> $<span style="font-weight: bold; font-style: italic;">bar</span>
</pre>
</div>

<p>
You make a variable local to a function with <code>local</code>. Use it as
much as you can (kinda obvious).
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">myfun</span>() {
  local bar
  <span style="font-weight: bold; font-style: italic;">bar</span>=3
  <span style="font-weight: bold;">echo</span> $<span style="font-weight: bold; font-style: italic;">bar</span>
}

<span style="font-weight: bold; font-style: italic;">bar</span>=4
<span style="font-weight: bold;">echo</span> $<span style="font-weight: bold; font-style: italic;">bar</span>
myfun
<span style="font-weight: bold;">echo</span> $<span style="font-weight: bold; font-style: italic;">bar</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbd63e27" class="outline-3">
<h3 id="orgbd63e27"><span class="section-number-3">4.8</span> Variable Expansions</h3>
<div class="outline-text-3" id="text-4-8">
<p>
They offer some variable manipulations using shell only, not having
to create another process <code>sed,awk,perl</code>.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;">v</span>=banana
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">substitute one</span>
<span style="font-weight: bold;">echo</span> ${<span style="font-weight: bold; font-style: italic;">v</span>/na/NA}   <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">baNAna</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">substitute many</span>
<span style="font-weight: bold;">echo</span> ${<span style="font-weight: bold; font-style: italic;">v</span>//na/NA}  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">baNANA</span>

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">substitute from the start (think ^ in PCRE)</span>
<span style="font-weight: bold;">echo</span> ${<span style="font-weight: bold; font-style: italic;">v</span>/#ba/NA}  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">NAnana</span>

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">substitute from the end</span>
<span style="font-weight: bold;">echo</span> ${<span style="font-weight: bold; font-style: italic;">v</span>/%na/NA}  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">banaNA</span>
</pre>
</div>

<p>
Take a read on <a href="https://tldp.org/LDP/abs/html/manipulatingvars.html">https://tldp.org/LDP/abs/html/manipulatingvars.html</a>
and
<a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html">https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html</a>
for more details.
</p>

<p>
And a nice non-obvious trick from here is to prefix or suffix a
variable string:
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;">v</span>=banana
<span style="font-weight: bold;">echo</span> ${<span style="font-weight: bold; font-style: italic;">v</span>/%/na}   <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">bananana</span>
<span style="font-weight: bold;">echo</span> ${<span style="font-weight: bold; font-style: italic;">v</span>/#/na}   <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">nabanana</span>
</pre>
</div>

<p>
And a less obvious trick is to prefix every element of an array
with a fixed string:
</p>
<div class="org-src-container">
<pre class="src src-bash">local <span style="font-weight: bold; font-style: italic;">arr</span>=(<span style="font-weight: bold; font-style: italic;">var1</span>=1 <span style="font-weight: bold; font-style: italic;">var2</span>=2)
<span style="font-weight: bold;">echo</span> ${<span style="font-weight: bold; font-style: italic;">arr</span>[*]/#/<span style="font-style: italic;">"--env "</span>}
</pre>
</div>

<p>
This will produce <code>--env var1=1 --env var2=2</code>.  Super useful to be
combined when building flags for docker.
</p>
</div>
</div>
<div id="outline-container-org5ee6fa6" class="outline-3">
<h3 id="org5ee6fa6"><span class="section-number-3">4.9</span> Interpolation</h3>
<div class="outline-text-3" id="text-4-9">
<p>
We previously saw that functions can be passed around as strings,
and be called later on.
</p>

<p>
Something that might not be obvious is that the string can be
created from shorter strings, and that allows for an extra
flexibility, that comes with its own dangers, but it's a very
useful pattern to dispatch functions based on user input or
function outputs.
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;">l</span>=l
<span style="font-weight: bold; font-style: italic;">s</span>=s
$<span style="font-weight: bold; font-style: italic;">l</span>$<span style="font-weight: bold; font-style: italic;">s</span> .
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc6606fa" class="outline-3">
<h3 id="orgc6606fa"><span class="section-number-3">4.10</span> dispatch functions using args</h3>
<div class="outline-text-3" id="text-4-10">
<p>
A nice usage of the previous technique is using user's input as a
dispatching method.
</p>

<p>
You've probably seen this pattern already:
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">while</span> [[ $<span style="font-weight: bold; font-style: italic;">#</span> -gt 0 ]]; <span style="font-weight: bold;">do</span>

<span style="font-weight: bold;">case</span> $<span style="font-weight: bold; font-style: italic;">1</span><span style="font-weight: bold;"> in</span>
  foo)
    foo
    ;;
  *)
    <span style="font-weight: bold;">exit</span> 1
    ;;
<span style="font-weight: bold;">esac</span>
<span style="font-weight: bold;">shift</span>
<span style="font-weight: bold;">done</span>
</pre>
</div>

<p>
And it is useful for its own good, and flexible.
</p>

<p>
But for some simpler cases, we can dispatch based on the variable
itself:
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">cmd_foo</span>() {
 do-something
}

cmd_$<span style="font-weight: bold; font-style: italic;">1</span>
</pre>
</div>

<p>
The problem with this is that in case we supply a <code>$1</code> that doesn't
map to any <code>cmd_$1</code> we'll get something like
</p>

<div class="org-src-container">
<pre class="src src-bash">bash: cmd_notexisting: command not found
</pre>
</div>
</div>
</div>

<div id="outline-container-org203d91b" class="outline-3">
<h3 id="org203d91b"><span class="section-number-3">4.11</span> command_not_found_handle</h3>
<div class="outline-text-3" id="text-4-11">
<p>
Here's a detail on a kinda obscure bash (only bash) feature.
</p>

<p>
You can set a hook that will be called when bash tries to run a
command and it doesn't find it.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">command_not_found_handle</span>() {
  <span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"$1 is not a correct command. Cmds allowed:"</span>
  <span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"$(typeset -F | grep cmd_ | sed -e 's/.*cmd_/cmd_/')"</span>
}

<span style="font-weight: bold;">cmd_foo</span>() {
  <span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"foo"</span>
}

<span style="font-weight: bold;">cmd_baz</span>() {
  <span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"baz"</span>
}
cmd_bar
</pre>
</div>

<p>
you can unset the function <code>command_not_found_handle</code> to go back to
the normal behavior.
</p>
</div>
</div>

<div id="outline-container-org1809b8b" class="outline-3">
<h3 id="org1809b8b"><span class="section-number-3">4.12</span> Return Values for Conditionals</h3>
<div class="outline-text-3" id="text-4-12">
<p>
<code>if</code> 's test condition can use the return values of
commands. That's a known thing, but lots of code you see around
rely on <code>[[]]</code> to test the return values of commands/functions
anyway.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">if </span><span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"foo"</span> | grep <span style="font-style: italic;">"bar"</span> ; <span style="font-weight: bold;">then</span>
  <span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"found!"</span>
<span style="font-weight: bold;">fi</span>
</pre>
</div>

<p>
This is much clearer than
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">if</span> [[ ! -z $( <span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"foo"</span> | grep <span style="font-style: italic;">"bar"</span>) ]]; <span style="font-weight: bold;">then</span>
  <span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"found!"</span>
<span style="font-weight: bold;">fi</span>
</pre>
</div>

<p>
As easy and trivial as it seems, this way of thinking pushes you
forward to thinking on creating smaller functions that check the
conditions and <code>return</code> 0 or non 0. It's syntactically smaller, and
usually makes you play by the rules of the commands, more than just
finding your way around the output strings.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">if</span> less_than $<span style="font-weight: bold; font-style: italic;">package</span> <span style="font-style: italic;">"1.3.2"</span>; <span style="font-weight: bold;">then</span>
  die <span style="font-style: italic;">"can't proceed"</span>
<span style="font-weight: bold;">fi</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd05d399" class="outline-3">
<h3 id="orgd05d399"><span class="section-number-3">4.13</span> Do work on loop conditions</h3>
<div class="outline-text-3" id="text-4-13">
<p>
I've not seen it used a lot (and there might be a reason for it,
who knows), <code>while</code> conditions are just plain commands, so you can
put other stuff than <code>[]/[[]]/test</code> there.
</p>

<p>
Heres's an idiomatic way to iterate through all the arguments of a
function while consuming the <code>$*</code> array.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">while</span>(($<span style="font-weight: bold; font-style: italic;">#</span>)) ; <span style="font-weight: bold;">do</span>
  <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">...</span>
  <span style="font-weight: bold;">shift</span>
<span style="font-weight: bold;">done</span>
</pre>
</div>

<p>
And here's a pseudo-repl that keeps shooting one-off commands. This
will keep shooting <code>tr</code> commands to whatever strings you give it,
with the usual rlwrap goodies.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">while</span> rlwrap -o -S<span style="font-style: italic;">'&gt;&gt; '</span> tr a-z A-Z ; <span style="font-weight: bold;">do</span> :; <span style="font-weight: bold;">done</span>
</pre>
</div>

<p>
Note: <code>:</code> is a nop builtin in bash.
</p>
</div>
</div>
<div id="outline-container-org1c808b0" class="outline-3">
<h3 id="org1c808b0"><span class="section-number-3">4.14</span> One Branch Conditionals</h3>
<div class="outline-text-3" id="text-4-14">
<p>
The usual conditionals one sees everywhere look like <code>if</code>.
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">if</span> [[ some-condition ]]; <span style="font-weight: bold;">then</span>
  <span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"yes"</span>
<span style="font-weight: bold;">fi</span>
</pre>
</div>

<p>
This is all good and fine, but in the same vein of using the least
powerful construct for each task, it's nice to think of the one way
conditionals in the form of <code>&amp;&amp;</code> and <code>||</code> as a way to explicitly
say that we don't want to do anything else when the condition is
not met. It's a hint to the reader.
</p>

<div class="org-src-container">
<pre class="src src-bash">some-condition || {
   <span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"log: warning!"</span>
}

other-condition &amp;&amp; {
   <span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"log: all cool"</span>
}
</pre>
</div>

<p>
This conveys the intention of doing something <b>just</b> in one case,
and that the negation of this is not interesting at all. There's a
big warning you have to be aware of. The same as with lua's
<code>... and .. or ..</code>, bash <code>||</code> and <code>&amp;&amp;</code> are not interchangeable for
<code>if...else...end</code>. <a href="https://mywiki.wooledge.org/BashPitfalls#cmd1_.26.26_cmd2_.7C.7C_cmd3">BashWiki</a> has an explanation why, but, the same
as in Lua's case, if the "then" part returns false, the else will
run.
</p>

<p>
There are lots of references to this, but I like this recent post
where it explains it for arrays in higher level languages like ruby:
<a href="https://jesseduffield.com/array-functions-and-the-rule-of-least-power/">https://jesseduffield.com/array-functions-and-the-rule-of-least-power/</a>
</p>

<p>
An extended article of this kind of conditionals can be found <a href="https://timvisee.com/blog/elegant-bash-conditionals/">here</a>.
</p>
</div>
</div>
<div id="outline-container-org1bfec80" class="outline-3">
<h3 id="org1bfec80"><span class="section-number-3">4.15</span> pushd/popd</h3>
<div class="outline-text-3" id="text-4-15">
<p>
pushd and popd are used to move to some directory and go back to it
in a stack fashion, so nesting can happen and you never lose
track. The problem is that it still is on you to have a <code>popd</code> per
<code>pushd</code>.
</p>
<div class="org-src-container">
<pre class="src src-bash">pushd /tmp/my-dir
  <span style="font-weight: bold;">echo</span> $<span style="font-weight: bold; font-style: italic;">PWD</span>
popd
</pre>
</div>

<p>
Here's an alternative way, that at least makes sure that you close
all pushd with a popd.
</p>

<p>
Starting a new shell and cd-ing , will make all commands in that
subshell be in that directory, and will come back to the old
directory after closing the new spawned shell.
</p>

<div class="org-src-container">
<pre class="src src-bash">(<span style="font-weight: bold;">cd</span> /tmp/my-dir
  ls
)
</pre>
</div>

<p>
Remember to <code>inherit_errexit</code> or <code>set -e</code> inside the subshell if
you need. That's a very easy trap to fall into.
</p>
</div>
</div>

<div id="outline-container-org05be41a" class="outline-3">
<h3 id="org05be41a"><span class="section-number-3">4.16</span> wrap functions</h3>
<div class="outline-text-3" id="text-4-16">
<p>
Bash can't pass blocks of code around, but the alternative is to
pass functions.  More on that later.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">mute</span>() {
  $<span style="font-weight: bold; font-style: italic;">@</span> &gt;/dev/null
}

mute ls
</pre>
</div>
</div>
</div>
<div id="outline-container-org1615023" class="outline-3">
<h3 id="org1615023"><span class="section-number-3">4.17</span> use [[</h3>
<div class="outline-text-3" id="text-4-17">
<p>
Unless you want your script to be POSIX compliant, use <code>[[</code> instead
of <code>[</code>.  <code>[</code> is a regular command. It's like <code>ls</code>, or <code>true</code>. You can
check it by searching for a file named <code>[</code> in your path.
</p>

<p>
Being a normal command it always evaluates its params, like a
regular function. On the other hand though, <code>[[</code> is a special bash
operator, and it evaluates the parameters lazily.
</p>

<div class="org-src-container">
<pre class="src src-bash">
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">[[ does lazy evaluation:</span>
[[ a = b &amp;&amp; $(<span style="font-weight: bold;">echo</span> foo &gt;&amp;2) ]]

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">[ does not:</span>
[ a = b -a <span style="font-style: italic;">"$(echo foo &gt;&amp;2)&#8221; ]</span>
</pre>
</div>
<p>
Ref: <a href="https://lists.gnu.org/archive/html/help-bash/2014-06/msg00013.html">https://lists.gnu.org/archive/html/help-bash/2014-06/msg00013.html</a>
</p>
</div>
</div>

<div id="outline-container-org3fb36bf" class="outline-3">
<h3 id="org3fb36bf"><span class="section-number-3">4.18</span> eval?</h3>
<div class="outline-text-3" id="text-4-18">
<p>
When you have mostly small functions that are mostly pure, you
compose them like you'd do in any other language.
</p>

<p>
In the following snippet, we are in a release script. Some step
builds a package inside an image, another step tests a package
already built.
</p>

<p>
A nice way to build ubuntus, for example, is to add an ARG to the
Dockerfile so we can build several ubuntu versions using the same
file.
</p>

<p>
It'd look something like this:
</p>
<div class="org-src-container">
<pre class="src src-Dockerfile">ARG VERSION
FROM ubuntu:$VERSION

RUN apt-get ...
...
</pre>
</div>

<p>
We build that image and do all the building inside it, mounting a
volume shared with our host, so we can extract our <code>.deb</code> file
easily.
</p>

<p>
After that, to do some smoke tests on the package, the idea is to
install the <code>.deb</code> file in a fresh ubuntu image.
</p>

<p>
Let's pick the same base image we picked to build the package.
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">evaluate the string "centos:$VERSION" (that comes from</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">centos/Dockerfile) in the current scope</span>
local <span style="font-weight: bold; font-style: italic;">VERSION</span>=$(get_version $<span style="font-weight: bold; font-style: italic;">DISTRO</span>)
run_test <span style="font-style: italic;">"file.deb"</span> <span style="font-style: italic;">"$(eval echo $(awk '/^FROM /{print $2; exit}' $LOCAL_PATH/$(get_dockerfile_for $DISTRO)))"</span>
</pre>
</div>

<p>
The usage of eval is there to interpolate the string that we get
from the <code>FROM</code> in the current environment.
</p>

<p>
WARNING: You know, anything that uses <code>eval</code> is dangerous per
se. Do not use it unless you know very well what you're doing AND
the input is 100% under your control. Usually, more restricted
commands can achieve what you want to do. In this particular case,
you could use <code>envsubst</code>, or just manually replace <code>$\{?VERSION\}?</code>
in a sed.
</p>

<div class="org-src-container">
<pre class="src src-bash">test_release <span style="font-style: italic;">"$PACKAGE_PATH"</span> $(awk <span style="font-style: italic;">'/^FROM /{print $2; exit}'</span> $<span style="font-weight: bold; font-style: italic;">LOCAL_PATH</span>/$(get_dockerfile_for $<span style="font-weight: bold; font-style: italic;">DISTRO</span>) | sed -e <span style="font-style: italic;">"s/\$VERSION/$VERSION/"</span>)
</pre>
</div>

<p>
Yet another way is using <a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html">shell parameter expansions.</a>
</p>
<div class="org-src-container">
<pre class="src src-bash">
<span style="font-weight: bold; font-style: italic;">var1</span>=value
<span style="font-weight: bold;">echo</span> <span style="font-style: italic;">'this is $var1'</span> &gt;/tmp/f.txt
<span style="font-weight: bold; font-style: italic;">f</span>=$(cat /tmp/f.txt)
<span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"${f}"</span>  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">this is $var1</span>
<span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"${f@P}"</span>  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">this is value</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb370f4f" class="outline-3">
<h3 id="orgb370f4f"><span class="section-number-3">4.19</span> pass commands around</h3>
<div class="outline-text-3" id="text-4-19">
<p>
This one uses <a href="#orgfc8aa1e">DRY_RUN</a>. While refactoring a script that does some
curls, we want to make sure that our refactored version does the
exact same calls in the same order.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">compare_outputs</span>() {
  <span style="font-weight: bold;">export</span> <span style="font-weight: bold; font-style: italic;">DRY_RUN</span>=1
  git checkout b1
  $<span style="font-weight: bold; font-style: italic;">@</span> 2&gt;/tmp/1.out
  git checkout b2
  $<span style="font-weight: bold; font-style: italic;">@</span> 2&gt;/tmp/2.out
  <span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"diffing"</span>
  diff /tmp/1.out /tmp/2.out
}
compare_outputs ./release.sh -p rhel:6 -R <span style="font-style: italic;">'internal-preview'</span>
</pre>
</div>

<p>
First we create a function <code>compare_outputs</code>, that gets a command
to run as parameters. The function will run it once, redirecting
the standard error to a file <code>/tmp/1.out</code>.
</p>

<p>
Then, it checks out the branch that contains our refactored
version, and will run the command again, redirecting standard error
to <code>/tmp/2.out</code>, and will diff the two outputs.
</p>

<p>
In case there's a difference between the two, <code>diff</code> will output
them, and the function will return the non-zero exit value of
diff. If everything went fine, <code>compare_outputs</code> will succeed.
</p>

<p>
Now that we know that for these inputs the command runs fine, we
want to find out if it works for other types of releases, not only
internal-preview.
</p>

<p>
Here I'm using zsh's global aliases to give a much more fluid
interface to the commands, but you can use the regular while/for
loops:
</p>

<div class="org-src-container">
<pre class="src src-shell">alias -g <span style="font-weight: bold; font-style: italic;">SPLIT</span>=<span style="font-style: italic;">'| tr " " "\n" '</span>
alias -g <span style="font-weight: bold; font-style: italic;">FORI</span>=<span style="font-style: italic;">'| while read i ; do '</span>
alias -g <span style="font-weight: bold; font-style: italic;">IROF</span>=<span style="font-style: italic;">'; done '</span>

<span style="font-weight: bold;">set</span> -e
<span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"ga internal-preview rc1 rc2"</span> SPLIT FORI
   noglob compare_outputs ./release.sh -p rhel:8 -R <span style="font-style: italic;">"$i"</span>
IROF
</pre>
</div>

<p>
So, combining the two, we can have a really smooth way of iterating
over the possibilities, without really messing into the details of
loops.
</p>

<p>
WARNING: This approach is not robust enough to put it anywhere in
production, but to write quick one off scripts is a
killer. Experimenting in a shell and creating tools and 2nd order
tools to make interaction faster builds a language that grows on
you, and keeps improving your toolbelt.
</p>
</div>
</div>

<div id="outline-container-org4251c9e" class="outline-3">
<h3 id="org4251c9e"><span class="section-number-3">4.20</span> The Toplevel Is Hopeless<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup></h3>
<div class="outline-text-3" id="text-4-20">
<p>
Shellscripts are thought as quick one-off programs, but when they
are useful, they are sticky, so you better write them from the
start as if it would be permanent. The upfront cost is very low
anyway. Structure the script like a regular app.
</p>

<p>
Bash is extremely permissive in what it allows to be coded and
ran. By default, failures do not make the program exit or throw an
exeption (no exceptions here). And for some reason, the common
usage of shellscripts is to put everything in the top level. Don't
do that. Do the least possible things in the toplevel.
</p>

<p>
A way to improve the defaults, is setting a bunch of flags that
make the script stricter, so it fails on many situations you'd
want to stop anyway because something went wrong.
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">!/usr/bin/</span><span style="font-weight: bold;">env</span><span style="font-weight: bold; font-style: italic;"> bash</span>
<span style="font-weight: bold;">set</span> -eEuo pipefail
shopt -s inherit_errexit

<span style="font-weight: bold;">main</span>() {
  parse_args
  validate_args
  do_things
  cleanup
}

main <span style="font-style: italic;">"$@"</span>
</pre>
</div>

<p>
Ref: <a href="https://dougrichardson.us/2018/08/03/fail-fast-bash-scripting.html">https://dougrichardson.us/2018/08/03/fail-fast-bash-scripting.html</a>
</p>
</div>
</div>

<div id="outline-container-org33c329c" class="outline-3">
<h3 id="org33c329c"><span class="section-number-3">4.21</span> Check your deps</h3>
<div class="outline-text-3" id="text-4-21">
<p>
Giving useful information to the user will only help them using the
script, and you debugging it.  This is a common use case, so let's
do it nicely.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">deps</span>() {
  <span style="font-weight: bold;">for</span> dep<span style="font-weight: bold;"> in</span> <span style="font-style: italic;">"$@"</span>; <span style="font-weight: bold;">do</span>
    mute which <span style="font-style: italic;">"$dep"</span> || die <span style="font-style: italic;">"$dep dependency missing"</span>
  <span style="font-weight: bold;">done</span>
}

<span style="font-weight: bold;">main</span>() {
  deps jq curl
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">...</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8a8f4d4" class="outline-3">
<h3 id="org8a8f4d4"><span class="section-number-3">4.22</span> source files</h3>
<div class="outline-text-3" id="text-4-22">
<p>
<code>source</code> is like <code>require</code> or <code>import</code> in some programming
languages. It evaluates the sourced file in the context of the
current script, so you get all definitions in your environment.
</p>

<p>
It's simple, but it helps you get used to modularize your code into
libraries.
</p>

<p>
Be careful, it's very rudimentary, and it will be overwriting old
vars or functions if names clash. There's no namespacing happening
there.
</p>

<div class="org-src-container">
<pre class="src src-bash">source file.sh

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">the same</span>
. file.sh
</pre>
</div>
</div>
</div>

<div id="outline-container-orgeefc21f" class="outline-3">
<h3 id="orgeefc21f"><span class="section-number-3">4.23</span> Use Scripts as a Libs</h3>
<div class="outline-text-3" id="text-4-23">
<p>
A python-inspired way of using scripts as loadable libraries is to
check whether the current file was the one that was called
originally or it's being just sourced.
</p>

<p>
Again, no side effects in load time makes this functionality
possible. otherwise, you're on your own.
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Allow sourcing of this script</span>
<span style="font-weight: bold;">if</span> [[ $(basename <span style="font-style: italic;">"$(realpath "$0")"</span>) == <span style="font-style: italic;">"${BASH_SOURCE}"</span> ]]; <span style="font-weight: bold;">then</span>
  setup
  parse_args <span style="font-style: italic;">"$@"</span>
  main
<span style="font-weight: bold;">fi</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org4db8a8b" class="outline-3">
<h3 id="org4db8a8b"><span class="section-number-3">4.24</span> Tmpfiles Everywhere</h3>
<div class="outline-text-3" id="text-4-24">
<p>
Your script is not going to run alone. Don't assume paths are
fixed or known.
</p>

<p>
CI/CD Pipelines run many jobs in the same node and files can start
clashing.
</p>

<p>
Make use of <code>$(mktemp -d /tmp/foo-bar.XXXXX)</code>.  If you have to patch a
file, do it in a clean fresh copy. Don't modify files in old paths
</p>

<p>
If you HAVE TO modify paths, do it idempotently.  But really, don't do it.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">git_clone_tmp</span>() {
  local <span style="font-weight: bold; font-style: italic;">repo</span>=${<span style="font-weight: bold; font-style: italic;">1</span>:?repo is required}
  local <span style="font-weight: bold; font-style: italic;">ref</span>=${<span style="font-weight: bold; font-style: italic;">2</span>:?ref is required}
  <span style="font-weight: bold; font-style: italic;">tmpath</span>=$(mktemp -d <span style="font-style: italic;">"/tmp/cloned-$repo-XXXXX"</span>)
  on_exit <span style="font-style: italic;">"rm -rf $tmpath"</span>
  git clone -b ${<span style="font-weight: bold; font-style: italic;">ref</span>} $<span style="font-weight: bold; font-style: italic;">repo</span> $<span style="font-weight: bold; font-style: italic;">tmpath</span>
}
</pre>
</div>

<p>
CAVEAT: You have to manually delete the directory if you want it cleaned.
</p>
</div>
</div>

<div id="outline-container-orga5e58fd" class="outline-3">
<h3 id="orga5e58fd"><span class="section-number-3">4.25</span> Cleanup tasks with trap</h3>
<div class="outline-text-3" id="text-4-25">
<p>
<code>trap</code> is used to 'subscribe' a callback when something happens.
Many times it's used on exit. It's a good thing to cleanup tmpdirs after your script
exits, so you can use the output of <code>mktemp -d</code> and subscribe a cleanup
function for it.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">on_exit</span>() {
  rm -rf $<span style="font-weight: bold; font-style: italic;">1</span>
}
local <span style="font-weight: bold; font-style: italic;">tmpath</span>=$(mktemp -d /tmp/foo-bar.XXXXX)
<span style="font-weight: bold;">trap</span> <span style="font-style: italic;">"on_exit $tmpath"</span> EXIT SIGINT
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf29c4d3" class="outline-3">
<h3 id="orgf29c4d3"><span class="section-number-3">4.26</span> array of callbacks on_exit</h3>
<div class="outline-text-3" id="text-4-26">
<p>
Level up that pattern, we can have a helper to add callbacks to run
on exit. Get used to these kind of patterns, they are super
powerful and save you lots of manual bookkeeping.
</p>

<div class="org-src-container">
<pre class="src src-bash">
<span style="font-weight: bold; font-style: italic;">ON_EXIT</span>=()
<span style="font-weight: bold; font-style: italic;">EXIT_RES</span>=

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">on_exit_fn</span> {
  <span style="font-weight: bold; font-style: italic;">EXIT_RES</span>=$<span style="font-weight: bold; font-style: italic;">?</span>
  <span style="font-weight: bold;">for</span> cb<span style="font-weight: bold;"> in</span> <span style="font-style: italic;">"${ON_EXIT[@]}"</span>; <span style="font-weight: bold;">do</span> $<span style="font-weight: bold; font-style: italic;">cb</span> || true; <span style="font-weight: bold;">done</span>
  <span style="font-weight: bold;">return</span> $<span style="font-weight: bold; font-style: italic;">EXIT_RES</span>
}

<span style="font-weight: bold;">trap</span> on_exit_fn EXIT SIGINT

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">on_exit</span> {
  ON_EXIT+=(<span style="font-style: italic;">"$@"</span>)
}

local <span style="font-weight: bold; font-style: italic;">v_id</span>=$(docker volume create)
on_exit <span style="font-style: italic;">"docker volume rm $v_id"</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Use your v_id knowing that it'll be available during your script but</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">will be cleaned up before exiting.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org33e60c3" class="outline-3">
<h3 id="org33e60c3"><span class="section-number-3">4.27</span> stacktrace on error</h3>
<div class="outline-text-3" id="text-4-27">
<p>
Here's a nice helper for debugging errors in bash. In case of non-0
exit, it prints a stacktrace.
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">set</span> -Eeuo pipefail
<span style="font-weight: bold;">trap</span> stacktrace EXIT
<span style="font-weight: bold;">stacktrace</span>() {
    <span style="font-weight: bold; font-style: italic;">rc</span>=<span style="font-style: italic;">"$?"</span>
    <span style="font-weight: bold;">if</span> [ $<span style="font-weight: bold; font-style: italic;">rc</span> != 0 ]; <span style="font-weight: bold;">then</span>
        printf <span style="font-style: italic;">'\nThe command "%s" triggerd a stacktrace:\n'</span> <span style="font-style: italic;">"$BASH_COMMAND"</span>
        <span style="font-weight: bold;">for</span> i<span style="font-weight: bold;"> in</span> $(seq 1 $((${#<span style="font-weight: bold; font-style: italic;">FUNCNAME</span>[@]} - 2))); <span style="font-weight: bold;">do</span>
          <span style="font-weight: bold; font-style: italic;">j</span>=$((i+1));
          printf <span style="font-style: italic;">'\t%s: %s() called in %s:%s\n'</span> <span style="font-style: italic;">"${BASH_SOURCE[$i]}"</span> <span style="font-style: italic;">"${FUNCNAME[$i]}"</span> <span style="font-style: italic;">"${BASH_SOURCE[$j]}"</span> <span style="font-style: italic;">"${BASH_LINENO[$i]}"</span>;
        <span style="font-weight: bold;">done</span>
    <span style="font-weight: bold;">fi</span>
}

</pre>
</div>
<p>
ref: <a href="https://news.ycombinator.com/item?id=26644110">https://news.ycombinator.com/item?id=26644110</a>
</p>
</div>
</div>
<div id="outline-container-org82782bb" class="outline-3">
<h3 id="org82782bb"><span class="section-number-3">4.28</span> Dots and colons allowed in function names!</h3>
<div class="outline-text-3" id="text-4-28">
<p>
A way to split the namespace is to have libs define functions with
their own namespace.
</p>

<p>
I've gotten used to use dots or colons as namespace separator.
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">semver.greater</span>() {
 <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">...</span>
}
</pre>
</div>
<p>
or
</p>
<div class="org-src-container">
<pre class="src src-bash">semver:greater() {
 <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">...</span>
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org008017a" class="outline-3">
<h3 id="org008017a"><span class="section-number-3">4.29</span> make steps of the process as composable as possible by using "$@"</h3>
<div class="outline-text-3" id="text-4-29">
<p>
By using <code>$@</code> to pass commands as parameters around you can get to
a degree of composability that allows for a nice chaining of
commands.
</p>

<p>
here's a very simple version of <code>watch</code>. See how you can <code>every 2
   ls -la</code>. I think that style is called Bernstein Chaining. But I'm
not sure. It also looks like currying to me if you squint a little
bit.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">every</span>() {
   <span style="font-weight: bold; font-style: italic;">secs</span>=$<span style="font-weight: bold; font-style: italic;">1</span>
   <span style="font-weight: bold;">shift</span>
   <span style="font-weight: bold;">while</span> true; <span style="font-weight: bold;">do</span>
     <span style="font-style: italic;">"$@"</span>
       sleep $<span style="font-weight: bold; font-style: italic;">secs</span>;
   <span style="font-weight: bold;">done</span>
 }

</pre>
</div>


<p>
As you know by now, bash doesn't pass blocks of code around, but
the alternative is to pass function names.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">mute</span>() {
  $<span style="font-weight: bold; font-style: italic;">@</span> &gt;/dev/null 2&gt;/dev/null
}
mute ls
</pre>
</div>

<p>
So now we can create the most stupid command composition ever:
</p>

<div class="org-src-container">
<pre class="src src-bash">every 1 mute echo hi
<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">or</span>
mute every 1 echo hi
</pre>
</div>

<p>
For the particular redirection problem, another option is to use
aliases. Redirects can be written anywhere on your CLI (not just at
the end), so the following will work using a plain alias:
</p>
<div class="org-src-container">
<pre class="src src-bash">alias <span style="font-weight: bold; font-style: italic;">null</span>=<span style="font-style: italic;">'&gt;/dev/null 2&gt;/dev/null'</span>
null ls
</pre>
</div>



<ul class="org-ul">
<li><a href="https://www.oilshell.org/blog/2017/01/13.html">https://www.oilshell.org/blog/2017/01/13.html</a></li>
</ul>
</div>
</div>
<div id="outline-container-org6af5998" class="outline-3">
<h3 id="org6af5998"><span class="section-number-3">4.30</span> do_times/foreach_*</h3>
<div class="outline-text-3" id="text-4-30">
<p>
shellscripts are highly side-efffecty, and even though the scoping
of variables is not very empowering, you can get a limited amount
of decomposition of loops by passing function names.
</p>

<p>
This is a lame example, but I hope it shows the use case, it allows
you to group already existing functions while taking advantage of a
fixed looping iterator, and leaving traces of the current loop vars
in the global "variable" environment.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">create_user</span>() {
  <span style="font-weight: bold; font-style: italic;">uname</span>=<span style="font-style: italic;">"u$1"</span> <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">leave uname in the global env so later functions see it</span>
  http :8080/users <span style="font-weight: bold; font-style: italic;">name</span>=<span style="font-style: italic;">"$uname"</span>
}

<span style="font-weight: bold;">create_pet</span>() {
  <span style="font-weight: bold; font-style: italic;">pname</span>=<span style="font-style: italic;">"p$1"</span>
  http :8080/users/$<span style="font-weight: bold; font-style: italic;">uname</span>/pets <span style="font-weight: bold; font-style: italic;">name</span>=<span style="font-style: italic;">"$pname"</span>
}

<span style="font-weight: bold;">create_bundle</span>() {
  create_user $<span style="font-weight: bold; font-style: italic;">1</span>
  create_pet $<span style="font-weight: bold; font-style: italic;">1</span>
}

<span style="font-weight: bold;">do_times</span>() {
  local <span style="font-weight: bold; font-style: italic;">n</span>=$<span style="font-weight: bold; font-style: italic;">1</span>; <span style="font-weight: bold;">shift</span>
  <span style="font-weight: bold;">for</span> i<span style="font-weight: bold;"> in</span> $(seq $<span style="font-weight: bold; font-style: italic;">n</span>); <span style="font-weight: bold;">do</span>
    <span style="font-style: italic;">"$@"</span> $<span style="font-weight: bold; font-style: italic;">i</span>
  <span style="font-weight: bold;">done</span>
}

do_times 15 create_bundle
</pre>
</div>

<p>
A bit more complex is runnning a command to every repo in an org:
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">run_tests</span>() {
  ./ci/test.sh
}

<span style="font-weight: bold;">foreach_repo_with_index</span>() {
  local <span style="font-weight: bold; font-style: italic;">counter</span>=0
  local <span style="font-weight: bold; font-style: italic;">repos</span>=$(http https://api.github.com/users/$<span style="font-weight: bold; font-style: italic;">1</span>/repos)
  <span style="font-weight: bold;">shift</span>
  <span style="font-weight: bold;">for</span> entry<span style="font-weight: bold;"> in</span> $(<span style="font-weight: bold;">echo</span> $<span style="font-weight: bold; font-style: italic;">repos</span> | jq -r <span style="font-style: italic;">'.[].git_url'</span>); <span style="font-weight: bold;">do</span>
    (git_clone_tmp $<span style="font-weight: bold; font-style: italic;">entry</span> master
     <span style="font-weight: bold;">cd</span> $<span style="font-weight: bold; font-style: italic;">tmpath</span>
     <span style="font-style: italic;">"$@"</span> $<span style="font-weight: bold; font-style: italic;">counter</span> $<span style="font-weight: bold; font-style: italic;">entry</span>
    )
    ((<span style="font-weight: bold; font-style: italic;">counter</span>=counter+1))
  <span style="font-weight: bold;">done</span>
}

foreach_repo_with_index kidd run_tests
</pre>
</div>
</div>
</div>

<div id="outline-container-org98d93c4" class="outline-3">
<h3 id="org98d93c4"><span class="section-number-3">4.31</span> &lt;(foo) and &gt;(foo)</h3>
<div class="outline-text-3" id="text-4-31">
<p>
Some commands ask for files as inputs. And sometimes you have that
file, but sometimes you're only creating that file to pass it to
the command.  In those cases, creating temporary files is not
necessary if you use <code>&lt;(cmd)</code>. Here's a way to diff the output of 2
commands without putting them in a temporary file.
</p>

<div class="org-src-container">
<pre class="src src-bash">diff &lt;(date) &lt;(date)
diff &lt;(date) &lt;(sleep 1; date)
</pre>
</div>

<p>
The same happens with outputs. Commands that ask you for a
destination file. You can trick them by using <code>&gt;(command)</code> as a
file. A nice trick is to use <code>&gt;(cat)</code> to know what's going on
there. Also useful to send stuff to the clipboard <code>&gt;(xclip)</code> before
running something on the output.
</p>

<p>
What the shell does in those cases is to bind a file descriptor of
the process created inside <code>&lt; or &gt;</code> to the first process.
</p>

<p>
You can experiment with those using commands like <code>echo &lt;(pwd)</code>.
</p>

<p>
In Zsh you can use <code>m-x expand-word</code> to see the file descriptors
being expanded.
</p>

<p>
A way to peek into a huge pipe is to <code>tee &gt;(cat)</code>
</p>
</div>
</div>

<div id="outline-container-org46ae66c" class="outline-3">
<h3 id="org46ae66c"><span class="section-number-3">4.32</span> Use xargs</h3>
<div class="outline-text-3" id="text-4-32">
<p>
Continuing with other ways of plumbing commands into other
commands, there's <code>xargs</code>. Some commands work seamlessly with
pipes, by taking inputs from stdin and printing to stdout.  But
some others like to work with files, and they ask for their
parameters in their args list. For example, <code>evince</code>. It wouldn't
be even expected to cat a pdf and pass it to evince through
stdin.
</p>

<p>
In general, to convert from this pattern: <code>cmd param</code> to <code>echo
   param| cmd</code>, xargs can be helpful. Look at its man page to know how
to split or batch args in multiple <code>cmd</code> calls.
</p>

<p>
Xargs is helpful for parallelizing work. You should look at its man
page, but just know it can help in running parallel processes
(check <code>-P</code> in its man).
</p>
</div>
</div>

<div id="outline-container-org714d83e" class="outline-3">
<h3 id="org714d83e"><span class="section-number-3">4.33</span> change loops for "mapping/reducing" functions</h3>
<div class="outline-text-3" id="text-4-33">
</div>
<div id="outline-container-org5922342" class="outline-4">
<h4 id="org5922342"><span class="section-number-4">4.33.1</span> find</h4>
<div class="outline-text-4" id="text-4-33-1">
<p>
Many times we want to run the same operation or test to lots of
files. Instead of looping for each file, think if <code>find -exec</code>
would solve it. Also, find supports multiple directories.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;">dirs</span>=(<span style="font-style: italic;">"/usr/local/bin"</span> <span style="font-style: italic;">"/usr/bin"</span>)
<span style="font-weight: bold;">for</span> d<span style="font-weight: bold;"> in</span> <span style="font-style: italic;">"${dirs[@]}"</span>; <span style="font-weight: bold;">do</span>
  <span style="font-weight: bold;">for</span> f<span style="font-weight: bold;"> in</span> $(find <span style="font-style: italic;">"$d"</span>); <span style="font-weight: bold;">do</span>
    <span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"check if owner of $f is johndoe and group is johndoe"</span>
    [ <span style="font-weight: bold;">`stat -c %U:%G $f`</span> == <span style="font-style: italic;">"johndoe:johndoe"</span> ] || die <span style="font-style: italic;">"error"</span>
  <span style="font-weight: bold;">done</span>
<span style="font-weight: bold;">done</span>
</pre>
</div>

<p>
Compare it to:
</p>

<div class="org-src-container">
<pre class="src src-bash">[ $(find <span style="font-style: italic;">"$dirs[@]"</span> -exec stat -c <span style="font-style: italic;">'%U:%G'</span> {} <span style="font-style: italic;">\;</span> | grep -vc <span style="font-style: italic;">"johndoe:johndoe"</span>) == <span style="font-style: italic;">"0"</span> ] || die <span style="font-style: italic;">"error"</span>
</pre>
</div>

<p>
Other examples might be:
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">count all lines of all docx in this dir</span>
find . -type f -name <span style="font-style: italic;">"*docx"</span> -exec pandoc <span style="font-style: italic;">"{}"</span> -t plain <span style="font-style: italic;">\;</span> | wc -l

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">All your files have the same owner and group permissions</span>
[ $(find <span style="font-style: italic;">"$files[@]"</span> -exec stat -c <span style="font-style: italic;">'%a'</span> {} <span style="font-style: italic;">\;</span> | grep -Evc <span style="font-style: italic;">"^(.)\1"</span>) == <span style="font-style: italic;">"0"</span> ]
</pre>
</div>
</div>
</div>
<div id="outline-container-org9817d6e" class="outline-4">
<h4 id="org9817d6e"><span class="section-number-4">4.33.2</span> grep -Fvf</h4>
<div class="outline-text-4" id="text-4-33-2">
<p>
Three magical flags that go well together.
</p>

<p>
<code>-f</code> list of patterns to match as a file.
<code>-F</code> interpret the "pattern" as a Fixed string, not a pattern/regex
<code>-v</code> negate the output. Print non matching lines.
</p>

<p>
The cool thing about combining <code>-f</code> and <code>-v</code> is that the negative
matches mean "lines that are not ANY of the ones in the pattern
list". So you can do list diffing. like <code>sort + diff</code> but more
flexible.
</p>

<p>
Here's a practical case of finding version numbers that we have a
tag for, that do not have a title in the readme
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;">f</span>=<span style="font-style: italic;">"readme.md"</span>
! grep -Fvf &lt;(grep -P <span style="font-style: italic;">"^# \d\.\d\.\d\.\d$"</span> <span style="font-style: italic;">"$f"</span> | sed -e <span style="font-style: italic;">'s/^# //'</span>) <span style="font-style: italic;">\</span>
            &lt;(git tag | grep -P <span style="font-style: italic;">"^\d\.\d\.\d\.\d$"</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgcb38cff" class="outline-3">
<h3 id="orgcb38cff"><span class="section-number-3">4.34</span> pass flags as a splatted array</h3>
<div class="outline-text-3" id="text-4-34">
<p>
There's quite a bit to chew on this example. First of all, the core
pattern is to build up your commandline options with an array, and
splat it in the final command line. For complex commands like
<code>docker</code> where you easily have 10+ flags it's a visual aid, and
also opens up the opportunities for reusing or abstracting sets of
options to logical blocks.
</p>

<p>
Once it's an array, we can add elements conditionally to that array
depending on the current run, and build the line that we'll be
running in the end.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Allows Ctrl-C'ing on interactive shells</span>
<span style="font-weight: bold; font-style: italic;">INTERACTIVE</span>=
<span style="font-weight: bold;">if</span> [[ -t 1 ]]; <span style="font-weight: bold;">then</span> <span style="font-weight: bold; font-style: italic;">INTERACTIVE</span>=<span style="font-style: italic;">"-it"</span>; <span style="font-weight: bold;">fi</span>

local <span style="font-weight: bold; font-style: italic;">flags</span>=(
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">We mount it as read-only, so we make sure we are not writing anything</span>
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">in there, and that everything is explicitly defined</span>
  <span style="font-style: italic;">"-v $LOCAL_PATH/build-dir:/build-dir:ro,delegated"</span>
  <span style="font-style: italic;">"-v $OUTPUT_DIR:/output:rw,consistent"</span>
  <span style="font-style: italic;">"-v $tmp_dir:/tmp/work:rw,delegated"</span>
)
<span style="font-weight: bold;">if</span> [[ -n $<span style="font-weight: bold; font-style: italic;">LOCAL_PATH</span> ]]; <span style="font-weight: bold;">then</span>
  flags+=(<span style="font-style: italic;">"-v $(realpath $LOCAL_PATH)/overrides/my-other-file:/build-dir/build.json:ro"</span>)
  flags+=(<span style="font-style: italic;">"-e LOCAL_PATH=/tmp/local"</span>)
<span style="font-weight: bold;">fi</span>

local <span style="font-weight: bold; font-style: italic;">v_id</span>=$(docker volume create)
flags+=(<span style="font-style: italic;">"-v $v_id:/tmp/build"</span>)
on_exit <span style="font-style: italic;">"docker volume rm $v_id"</span>

docker run --rm $<span style="font-weight: bold; font-style: italic;">INTERACTIVE</span> ${<span style="font-weight: bold; font-style: italic;">flags</span>[*]} $<span style="font-weight: bold; font-style: italic;">image</span> touch /tmp/build/foo.txt

docker run --rm $<span style="font-weight: bold; font-style: italic;">INTERACTIVE</span> ${<span style="font-weight: bold; font-style: italic;">flags</span>[*]} fpm:latest fpm-build /tmp/build/foo.txt
on_exit <span style="font-style: italic;">"chown_cache $tmp_dir"</span>
</pre>
</div>

<p>
In this example we see another cool trick. Mounting a volume in 2
differrent containers, so not for the purpose of sharing a local
file/dir with the host but to share it between themselves. In that
case, the 2 containers don't even coexist temporarily, but use the
volume as a conveyor belt, passing it from container to container,
and each one applies "its thing".
</p>

<p>
After all the mess, someone has to cleanup everything, but we know
how to do it with <code>on_exit</code> trick.
</p>
</div>
</div>

<div id="outline-container-org6e9c1ea" class="outline-3">
<h3 id="org6e9c1ea"><span class="section-number-3">4.35</span> inherit_errexit</h3>
<div class="outline-text-3" id="text-4-35">
<p>
bash 4.4+ , you can <code>shopt -s inherit_errexit</code>, and subshells will
inherit the errexit flag value. meaning that if you <code>set -Ee</code>,
anything that runs inside a subshell will throw an error at the
moment any command exits with <code>!=0</code>.
</p>
</div>
</div>
<div id="outline-container-org3863d9a" class="outline-3">
<h3 id="org3863d9a"><span class="section-number-3">4.36</span> GNU Parallel</h3>
<div class="outline-text-3" id="text-4-36">
<p>
I can't recommend <a href="https://www.gnu.org/software/parallel/">parallel</a> enough. The same as xargs, but in a
much more flexible way, parallel lets you run various jobs at a
time. If you have this tool into account, it doesn't just speed up
your runtimes, but it will force you write cleaner code. Parallel
execution will test your scripts so if they are not using
randomized tmp working directories, things will clash, etc&#x2026;
</p>

<p>
Parallel in itself is such a hackerfriendly tool it deserves to be
deeply learned. You can use it just locally to run a process per
core, you can send jobs to several machines connected via a simple
ssh, you can bind tmux or sqlite to it, or you can write a trivial
job queuing system.
</p>

<p>
Man pages and official examples are a goldmine.
</p>
</div>
</div>

<div id="outline-container-org00292fd" class="outline-3">
<h3 id="org00292fd"><span class="section-number-3">4.37</span> HEREDOCS</h3>
<div class="outline-text-3" id="text-4-37">
<ul class="org-ul">
<li>Basic usage of heredocs:</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash">     <span style="font-weight: bold;">echo</span> &lt;&lt;EOF
<span style="font-weight: bold;">$interpolated</span>
<span style="font-weight: bold;">\$non_interpolated</span>
<span style="font-weight: bold;">EOF</span>
</pre>
</div>

<ul class="org-ul">
<li>A dash after <code>&lt;&lt;</code> replaces trailing spaces in here docs</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">echo</span> &lt;&lt;-EOF
<span style="font-weight: bold;">$var</span>
<span style="font-weight: bold;">there</span>
<span style="font-weight: bold;">EOF</span>
</pre>
</div>

<ul class="org-ul">
<li>quoting the identifier disables interpolation of variables</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">echo</span> &lt;&lt;<span style="font-style: italic;">'EOF'</span>
<span style="font-weight: bold;">$non_interpolated</span>
<span style="font-weight: bold;">there</span>
<span style="font-weight: bold;">EOF</span>
</pre>
</div>

<p>
The <a href="http://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Here-Documents">bash manual</a> is super concise and to the point there.
</p>
</div>
</div>
</div>
<div id="outline-container-orge306d07" class="outline-2">
<h2 id="orge306d07"><span class="section-number-2">5</span> Interactive</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgd1af760" class="outline-3">
<h3 id="orgd1af760"><span class="section-number-3">5.1</span> Save your small scripts</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Rome wasn't built in a day, and like having a journal log, most of
the little scripts you create, once you have enough discipline will
be useful for some other cases, and your functions will be
reusable.
</p>

<p>
Save your scripts into files early on, instead of crunching
everything in the repl. learn how to use a decent editor that
shortens the feedback cycle as much as possible.
</p>
</div>
</div>
<div id="outline-container-org5e6e96b" class="outline-3">
<h3 id="org5e6e96b"><span class="section-number-3">5.2</span> Increased Interactivity</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Knowing your shell's shortcuts for interactive use is a must. The
same way you learned to touchtype and you learned your editor, you
should learn all the shortcuts for your shell. Here's some of them.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">key</th>
<th scope="col" class="org-left">action</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Ctrl-r</td>
<td class="org-left">reverse-history-search</td>
</tr>

<tr>
<td class="org-left">C-a</td>
<td class="org-left">beginning-of-line</td>
</tr>

<tr>
<td class="org-left">C-e</td>
<td class="org-left">end-of-line</td>
</tr>

<tr>
<td class="org-left">C-w</td>
<td class="org-left">delete-word-backwards</td>
</tr>

<tr>
<td class="org-left">C-k</td>
<td class="org-left">kill-line (from point to eol)</td>
</tr>

<tr>
<td class="org-left">C-y</td>
<td class="org-left">paste last killed thing</td>
</tr>

<tr>
<td class="org-left">A-y</td>
<td class="org-left">previous killed thing (after a c-y)</td>
</tr>

<tr>
<td class="org-left">C-p</td>
<td class="org-left">previous-line</td>
</tr>

<tr>
<td class="org-left">C-n</td>
<td class="org-left">next-line</td>
</tr>

<tr>
<td class="org-left">A-.</td>
<td class="org-left">insert last agument</td>
</tr>

<tr>
<td class="org-left">A-/</td>
<td class="org-left">dabbrev-expand</td>
</tr>
</tbody>
</table>

<p>
A written form of <code>A-.</code> is <code>$_</code>. It retains the last argment and
puts it in $_.  <code>test -f "FILE" &amp;&amp; source "$_"</code>.
</p>
</div>
</div>

<div id="outline-container-org962892c" class="outline-3">
<h3 id="org962892c"><span class="section-number-3">5.3</span> Aliases</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Aliases are very simple substitutions of commands for a sequence of
other commands.  Usual example is
</p>

<div class="org-src-container">
<pre class="src src-bash">alias <span style="font-weight: bold; font-style: italic;">ls</span>=<span style="font-style: italic;">'ls --auto-color'</span>
</pre>
</div>

<p>
Now let's move on to the interesting stuff.
</p>
</div>
</div>

<div id="outline-container-org6020ef7" class="outline-3">
<h3 id="org6020ef7"><span class="section-number-3">5.4</span> functions can generate aliases</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Aliases live in a global namespace for the shell, so no matter
where you define them, they take effect globally, possibly
overwriting older aliases with the same name.
</p>

<p>
Well, it's not lexical scope (far from it), but using aliases you
can create a string that snapshots the value you want, and capture
it to run it later.
</p>

<p>
Some fun stuff:
</p>

<ul class="org-ul">
<li>aliasgen. Create an alias for each directory in
~/workspace/. This is superceeded by <code>CDPATH</code>, but the trick is
still cool.</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">aliasgen</span>() {
  <span style="font-weight: bold;">for</span> i<span style="font-weight: bold;"> in</span> ~/workspace/*(/) ; <span style="font-weight: bold;">do</span>
      <span style="font-weight: bold; font-style: italic;">DIR</span>=$(basename $<span style="font-weight: bold; font-style: italic;">i</span>) ;
       alias $<span style="font-weight: bold; font-style: italic;">DIR</span>=<span style="font-style: italic;">"cd ~/workspace/$i"</span>;
  <span style="font-weight: bold;">done</span>
}
aliasgen
</pre>
</div>

<ul class="org-ul">
<li>a make a shortcut to the current directory.</li>
</ul>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">a</span>() { alias $<span style="font-weight: bold; font-style: italic;">1</span>=cd<span style="font-style: italic;">\ </span>$<span style="font-weight: bold; font-style: italic;">PWD</span>; }

mkdir -p /tmp/fing-longer
<span style="font-weight: bold;">cd</span> /tmp/fing-longer
a fl
<span style="font-weight: bold;">cd</span> /
fl
<span style="font-weight: bold;">echo</span> $<span style="font-weight: bold; font-style: italic;">PWD</span>   <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">/tmp/fing-longer</span>
</pre>
</div>
<p>
A man can dream&#x2026;
</p>


<ul class="org-ul">
<li><p>
unhist. functions can create aliases, and functions can receive
functions as parameters (as a string (function name)), so we can
combine them to advise existing functions.
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">unhist</span> () {
  alias $<span style="font-weight: bold; font-style: italic;">1</span>=<span style="font-style: italic;">" $1"</span>
}
unhist unhist
unhist grep
unhist rg

<span style="font-weight: bold;">noglobber</span>() {
    alias $<span style="font-weight: bold; font-style: italic;">1</span>=<span style="font-style: italic;">"noglob $1"</span>
}
noglobber http
noglobber curl
noglobber git

</pre>
</div></li>

<li>Problem: These commands do not compose. Combination of 2 of those
doesn't work, because the second acts just on the textual
representation that it received, not the current value of the
alias.</li>
</ul>
</div>
</div>
<div id="outline-container-orgfe481dc" class="outline-3">
<h3 id="orgfe481dc"><span class="section-number-3">5.5</span> Override (advise?) common functions</h3>
<div class="outline-text-3" id="text-5-5">
<p>
Overriding commands is generally a bad practice as it violates the
principle of least surprise, but there might be occasions (mostly
in your local machine) where you can integrate awesome finetunnings
to your toolbelt.
</p>

<p>
Here we're going to get the original docker binary file
location. After that we declare a function called <code>docker</code> that
will proxy the parameters to the original <code>docker</code> program UNLESS
you're calling <code>docker run</code>. In that case, we're injecting a mouted
volume that mounts <code>/root/.bash_history</code> of the container to a file
hosted in the host (duh). That's a pretty cool way of keeping a
history of your recent commands in your containers, no matter how
many times you start and kill them.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;">DOCKER_ORIG</span>=$(which docker)
<span style="font-weight: bold;">docker</span> () {
    <span style="font-weight: bold;">if</span> [[ $<span style="font-weight: bold; font-style: italic;">1</span> == <span style="font-style: italic;">"run"</span> ]]; <span style="font-weight: bold;">then</span>
        <span style="font-weight: bold;">shift</span>
        $<span style="font-weight: bold; font-style: italic;">DOCKER_ORIG</span> run -v $<span style="font-weight: bold; font-style: italic;">HOME</span>/.shared_bash_history:/root/.bash_history <span style="font-style: italic;">"$@"</span>
    <span style="font-weight: bold;">else</span>
        $<span style="font-weight: bold; font-style: italic;">DOCKER_ORIG</span> <span style="font-style: italic;">"$@"</span>
    <span style="font-weight: bold;">fi</span>
}
</pre>
</div>

<p>
I'm particularly fond of this trick, as it saved me tons of
typing. But at a personal level, it was mindblowing that sharing
this around the internet caused the most disparity of opinions.
Also, I recently read the greate book "Docker in Practice" by <a href="https://github.com/ianmiell">Ian
Miell</a> and there's a snippet that is 99.9% like the one I
created myself. That was a very cool moment.
</p>
</div>
</div>

<div id="outline-container-org94434da" class="outline-3">
<h3 id="org94434da"><span class="section-number-3">5.6</span> Faster iteration on pipes</h3>
<div class="outline-text-3" id="text-5-6">
<p>
When testing complex pipelines:
</p>

<ul class="org-ul">
<li>Make them pure (no side effects).</li>
<li>One command per line.</li>
<li>End lines with the pipe character.</li>
<li>During development, end the pipeline with <code>cat</code>.</li>
</ul>

<p>
I usually use <code>watch -n1 'code.sh'</code> in a split window so I see the
results of what I'm doing. The advantage of
</p>

<div class="org-src-container">
<pre class="src src-bash">curl https://www.example.com/videos/              |
  pup <span style="font-style: italic;">'figure.mg &gt; a attr{href}'</span>                  |
  head -1                                         |
  xargs -I{} curl -L <span style="font-style: italic;">"https://www.example.com/{}"</span> |
  pup <span style="font-style: italic;">'script'</span>                                    |
  grep file:                                      |
  sed -e <span style="font-style: italic;">"s/.*\(http[^ \"']*\).*/\1/"</span>             |
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">xargs vlc                                       |</span>
  cat
</pre>
</div>

<p>
Over
</p>
<div class="org-src-container">
<pre class="src src-bash">curl https://www.example.com/videos/                <span style="font-style: italic;">\</span>
  | pup <span style="font-style: italic;">'figure.mg &gt; a attr{href}'</span>                  <span style="font-style: italic;">\</span>
  | head -1                                         <span style="font-style: italic;">\</span>
  | xargs -I{} curl -L <span style="font-style: italic;">"https://www.example.com/{}"</span> <span style="font-style: italic;">\</span>
  | pup <span style="font-style: italic;">'script'</span>                                    <span style="font-style: italic;">\</span>
  | grep file:                                      <span style="font-style: italic;">\</span>
  | sed -e <span style="font-style: italic;">"s/.*\(http[^ \"']*\).*/\1/"</span>             <span style="font-style: italic;">\</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">xargs vlc   # doesn't work</span>
</pre>
</div>

<p>
Is that you can comment out lines on the former one, but you can't
do that on the latter. The <code>cat</code> trick makes it so that you have an
'exit' point, and you don't have to comment that one. Also, some
editors will indent the first one correctly, while you'll have to
manually indent the second one.
</p>

<p>
Small wins that compose just fine :)
</p>
</div>
</div>
</div>

<div id="outline-container-orgf94e35c" class="outline-2">
<h2 id="orgf94e35c"><span class="section-number-2">6</span> Debugging</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orgf7ff040" class="outline-3">
<h3 id="orgf7ff040"><span class="section-number-3">6.1</span> adding <code>bash</code> to a script to debug</h3>
<div class="outline-text-3" id="text-6-1">
<p>
You can add <code>bash</code> inside any script, and it'll add a sort of
a breakpoint, allowing you to check the state of the env and
manually call functions around.
</p>

<p>
If you orgainse your code in small functions, it's easy to add
breakpoints by just spawning bash processes inside your script.
</p>

<p>
This works also inside docker containers (if you provide <code>-ti</code> flag
on run).
</p>

<p>
Let's see some usual uses of docker and how we can debug our
scripts there:
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">leaves you at a shell to fiddle if all is in place after build</span>
docker run -it mycomplex-image bash

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Runs /tmp/file.sh from the host inside. That's cool to make the</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">container less hermetic. Even if the image is not originally ment</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">to, you can even override it and 'monkeypatch' the file with the one</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">from the host anyway.</span>
docker run -it -v $<span style="font-weight: bold; font-style: italic;">PWD</span>:/tmp/ mycomplex-image /tmp/file.sh

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">So now you can really add wtv you want there.</span>
<span style="font-weight: bold;">echo</span> <span style="font-style: italic;">'bash'</span> &gt;&gt;$<span style="font-weight: bold; font-style: italic;">PWD</span>/file.sh

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">run+open shell at runtime to inspect the state of the script</span>
docker run -it -v $<span style="font-weight: bold; font-style: italic;">PWD</span>:/tmp/ mycomplex-image /tmp/file.sh
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfc8aa1e" class="outline-3">
<h3 id="orgfc8aa1e"><span class="section-number-3">6.2</span> DRY_RUN</h3>
<div class="outline-text-3" id="text-6-2">
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">if</span> [[-n <span style="font-style: italic;">"$DRY_RUN"</span> ]]; <span style="font-weight: bold;">then</span>
  curl () {
    <span style="font-weight: bold;">echo</span> curl <span style="font-style: italic;">"$@"</span>
  }
<span style="font-weight: bold;">fi</span>
</pre>
</div>
<p>
use <code>command curl</code> to force the command, not the alias or anything
</p>
</div>
</div>

<div id="outline-container-orgfe97a65" class="outline-3">
<h3 id="orgfe97a65"><span class="section-number-3">6.3</span> Cheap debugging flag</h3>
<div class="outline-text-3" id="text-6-3">
<div class="org-src-container">
<pre class="src src-bash">optargs <span style="font-style: italic;">"V"</span> option; <span style="font-weight: bold;">do</span>
<span style="font-weight: bold;">case</span> $<span style="font-weight: bold; font-style: italic;">option</span><span style="font-weight: bold;"> in</span>
  V)
    <span style="font-weight: bold;">set</span> -xa
  ;;
</pre>
</div>
</div>
</div>

<div id="outline-container-orge0b214e" class="outline-3">
<h3 id="orge0b214e"><span class="section-number-3">6.4</span> explore a pipe with tee &gt;(some_command) |</h3>
<div class="outline-text-3" id="text-6-4">
<p>
the <code>&gt;()</code> is not very easy to use. Very few places where it
fits. Here's a nice pipe inspector though, using <code>tee &gt;(cat 1&gt;&amp;2)</code>
trick.
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">plog</span>() {
  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">tee &gt;(cat 1&gt;&amp;2)</span>
  local <span style="font-weight: bold; font-style: italic;">msg</span>=${<span style="font-weight: bold; font-style: italic;">1</span>:-plog}
  tee &gt;(sed -e <span style="font-style: italic;">"s/^/[$msg] /"</span> 1&gt;&amp;2)
}
alias -g <span style="font-style: italic;">'PL'</span>=<span style="font-style: italic;">' |plog '</span> <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">zsh only</span>

<span style="font-weight: bold;">echo</span> <span style="font-style: italic;">"a\nb"</span> PL foo | tr <span style="font-style: italic;">'a-z'</span> <span style="font-style: italic;">'A-Z'</span> PL bar
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">output:</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">[foo] a     # stderr</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">[foo] b     # stderr</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">A           # stdout</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">B           # stdout</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">[bar] A     # stderr</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">[bar] b     # stderr</span>
</pre>
</div>


<p>
ref: <a href="https://stackoverflow.com/questions/17983777/shell-pipe-to-multiple-commands-in-a-file">https://stackoverflow.com/questions/17983777/shell-pipe-to-multiple-commands-in-a-file</a>
</p>
</div>
</div>


<div id="outline-container-org259caa9" class="outline-3">
<h3 id="org259caa9"><span class="section-number-3">6.5</span> tee+sudo</h3>
<div class="outline-text-3" id="text-6-5">
<p>
If you wat to store a file in a root-owned dir, in the middle of
your pipeline, instead of running the whole thing as root, you can
use <code>sudo tee file</code>:
</p>
<div class="org-src-container">
<pre class="src src-bash">ls | grep m &gt;/usr/local/garbage  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">fail</span>
ls | grep m | sudo tee /usr/local/garbage <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">success!</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org2e45843" class="outline-3">
<h3 id="org2e45843"><span class="section-number-3">6.6</span> quoting</h3>
<div class="outline-text-3" id="text-6-6">
<p>
Bash: To get a quoted version of a given string, here's what you can do:
</p>
<div class="org-src-container">
<pre class="src src-bash">
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">this is my "string" I want to 'comment "on"'</span>
!:q
</pre>
</div>

<p>
That gives us <code>'#this is my "string" I want to '\''comment
   "on"'\'''</code>. Neat!
</p>

<p>
I just found this trick <a href="https://til.simonwillison.net/til/til/bash_escaping-a-string.md">here</a>. From the associated HN thread:
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">bashquote</span> () {
  printf <span style="font-style: italic;">'%q'</span> <span style="font-style: italic;">"$(cat)"</span>
  <span style="font-weight: bold;">echo</span>
}
</pre>
</div>

<p>
Zsh: If you're on zsh, <code>a-'</code> quotes the current line.
</p>
</div>
</div>
</div>

<div id="outline-container-orgd4fa533" class="outline-2">
<h2 id="orgd4fa533"><span class="section-number-2">7</span> zsh-only</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-orge590cc8" class="outline-3">
<h3 id="orge590cc8"><span class="section-number-3">7.1</span> Word spliting</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Word splitting works differently by default in zsh than in bash.
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold; font-style: italic;">foo</span>=<span style="font-style: italic;">"ls -las"</span>
$<span style="font-weight: bold; font-style: italic;">foo</span>
</pre>
</div>
<p>
This works in bash, but zsh will not split by words. To make zsh
expand by words, there are 2 ways: <code>setopt SH_WORD_SPLIT</code> and
<code>${=foo}</code>.  zsh has <code>unsetop</code> command, which allows to scope where
you want the expansions to happen. <code>unsetop SH_WORD_SPLIT</code>.
</p>

<p>
The problem with both solutions is that none of them are compatible
with bash, so you'll be cornering yourself to "this only works in
zsh".  A way to overcome this is to use arrays, which are expanded
in the same way in both shells.
</p>

<p>
Or, use the same hack as you'll see later with noglob.
</p>

<p>
Refs:
</p>
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/6715388/variable-expansion-is-different-in-zsh-from-that-in-bash">https://stackoverflow.com/questions/6715388/variable-expansion-is-different-in-zsh-from-that-in-bash</a></li>
<li><a href="http://zsh.sourceforge.net/FAQ/zshfaq03.html#l18">http://zsh.sourceforge.net/FAQ/zshfaq03.html#l18</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgac80f99" class="outline-3">
<h3 id="orgac80f99"><span class="section-number-3">7.2</span> globbing</h3>
<div class="outline-text-3" id="text-7-2">
<p>
In zsh, getting a list of files that match some characteristics is
doable using globbing. Bash has globbing also, but in a less sophisticated way.
</p>

<p>
The basic structure of a <code>glob</code> is <code>pattern(qualifiers)</code>. Patterns
can contain:
</p>
<ul class="org-ul">
<li>strings: they do exact match</li>
<li>wildcards:  <code>*</code>, <code>?</code>, <code>**/</code></li>
<li>character classes: <code>[0-9]</code></li>
<li>choices:  <code>(.pdf|.djvu)</code></li>
</ul>

<p>
The qualifiers are extra constraints you put on the matches. There
are lots of different qualifiers. Look at <code>zshexpn</code> for the
complete list. The ones I use more are:
</p>

<ul class="org-ul">
<li><code>.</code> Files</li>
<li><code>/</code> Directories</li>
<li><code>om[numberhere]</code>. Nth latest modified</li>
</ul>
</div>
</div>

<div id="outline-container-org1a119a3" class="outline-3">
<h3 id="org1a119a3"><span class="section-number-3">7.3</span> Some global aliases:</h3>
<div class="outline-text-3" id="text-7-3">
<p>
These are some aliases I have in my ~/.zshrc that somehow help me
use a shell in a more fluid way.
</p>
<div class="org-src-container">
<pre class="src src-bash">alias -g <span style="font-weight: bold; font-style: italic;">P1</span>=<span style="font-style: italic;">'| awk "{print \$1}"'</span>
alias -g <span style="font-weight: bold; font-style: italic;">P2</span>=<span style="font-style: italic;">'| awk "{print \$2}"'</span>
alias -g <span style="font-weight: bold; font-style: italic;">P3</span>=<span style="font-style: italic;">'| awk "{print \$3}"'</span>
alias -g <span style="font-weight: bold; font-style: italic;">P4</span>=<span style="font-style: italic;">'| awk "{print \$4}"'</span>
alias -g <span style="font-weight: bold; font-style: italic;">P5</span>=<span style="font-style: italic;">'| awk "{print \$5}"'</span>
alias -g <span style="font-weight: bold; font-style: italic;">P6</span>=<span style="font-style: italic;">'| awk "{print \$6}"'</span>
alias -g <span style="font-weight: bold; font-style: italic;">PL</span>=<span style="font-style: italic;">'| awk "{print \$NF}"'</span>
alias -g <span style="font-weight: bold; font-style: italic;">PN</span>=<span style="font-style: italic;">'| awk "{print \$NF}"'</span>
alias -g <span style="font-weight: bold; font-style: italic;">HL</span>=<span style="font-style: italic;">'| head -20'</span>
alias -g <span style="font-weight: bold; font-style: italic;">H</span>=<span style="font-style: italic;">'| head '</span>
alias -g <span style="font-weight: bold; font-style: italic;">H1</span>=<span style="font-style: italic;">'| head -1'</span>
alias -g <span style="font-weight: bold; font-style: italic;">TL</span>=<span style="font-style: italic;">'| tail -20'</span>
alias -g <span style="font-weight: bold; font-style: italic;">T</span>=<span style="font-style: italic;">'| tail '</span>
alias -g <span style="font-weight: bold; font-style: italic;">T1</span>=<span style="font-style: italic;">'T -1'</span>
<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">alias -g tr='-ltr'</span>
alias -g <span style="font-weight: bold; font-style: italic;">X</span>=<span style="font-style: italic;">'| xclip  '</span>
alias -g <span style="font-weight: bold; font-style: italic;">TB</span>=<span style="font-style: italic;">'| nc termbin.com 9999 '</span>
alias -g <span style="font-weight: bold; font-style: italic;">L</span>=<span style="font-style: italic;">'| less -R '</span>
alias -g <span style="font-weight: bold; font-style: italic;">LR</span>=<span style="font-style: italic;">'| less -r '</span>
alias -g <span style="font-weight: bold; font-style: italic;">G</span>=<span style="font-style: italic;">'| grep '</span>
alias -g <span style="font-weight: bold; font-style: italic;">GI</span>=<span style="font-style: italic;">'| grep -i '</span>
alias -g <span style="font-weight: bold; font-style: italic;">GG</span>=<span style="font-style: italic;">' 2&gt;&amp;1 | grep '</span>
alias -g <span style="font-weight: bold; font-style: italic;">GGI</span>=<span style="font-style: italic;">' 2&gt;&amp;1 | grep -i '</span>
alias -g <span style="font-weight: bold; font-style: italic;">GV</span>=<span style="font-style: italic;">'| grep -v '</span>
alias -g <span style="font-weight: bold; font-style: italic;">V</span>=<span style="font-style: italic;">'| grep -v '</span>
alias -g <span style="font-weight: bold; font-style: italic;">TAC</span>=<span style="font-style: italic;">'| tac '</span>
alias -g <span style="font-weight: bold; font-style: italic;">DU</span>=<span style="font-style: italic;">'du -B1'</span>

alias -g <span style="font-weight: bold; font-style: italic;">E2O</span>=<span style="font-style: italic;">' 2&gt;&amp;1 '</span>
alias -g <span style="font-weight: bold; font-style: italic;">NE</span>=<span style="font-style: italic;">' 2&gt;/dev/null '</span>
alias -g <span style="font-weight: bold; font-style: italic;">NO</span>=<span style="font-style: italic;">' &gt;/dev/null '</span>

alias -g <span style="font-weight: bold; font-style: italic;">WC</span>=<span style="font-style: italic;">'| wc -l '</span>

alias -g <span style="font-weight: bold; font-style: italic;">J</span>=<span style="font-style: italic;">'| noglob jq'</span>
alias -g <span style="font-weight: bold; font-style: italic;">JQ</span>=<span style="font-style: italic;">'| noglob jq'</span>
alias -g <span style="font-weight: bold; font-style: italic;">jq</span>=<span style="font-style: italic;">'noglob jq'</span>
alias -g <span style="font-weight: bold; font-style: italic;">JL</span>=<span style="font-style: italic;">'| noglob jq -C . | less -R '</span>
alias -g <span style="font-weight: bold; font-style: italic;">JQL</span>=<span style="font-style: italic;">'| noglob jq -C . | less -R '</span>
alias -g <span style="font-weight: bold; font-style: italic;">XMEL</span>=<span style="font-style: italic;">'| xmlstarlet el'</span>
alias -g <span style="font-weight: bold; font-style: italic;">XML</span>=<span style="font-style: italic;">'| xmlstarlet sel -t -v '</span>

alias -g <span style="font-weight: bold; font-style: italic;">LYNX</span>=<span style="font-style: italic;">"| lynx -dump -stdin "</span>
alias -g <span style="font-weight: bold; font-style: italic;">H2T</span>=<span style="font-style: italic;">"| html2text "</span>
alias -g <span style="font-weight: bold; font-style: italic;">TRIM</span>=<span style="font-style: italic;">"| xargs "</span>
alias -g <span style="font-weight: bold; font-style: italic;">XA</span>=<span style="font-style: italic;">'| xargs -d"\n" '</span>
alias -g <span style="font-weight: bold; font-style: italic;">XE</span>=<span style="font-style: italic;">"| xargs e"</span>
alias -g <span style="font-weight: bold; font-style: italic;">P</span>=<span style="font-style: italic;">"| pick "</span>
alias -g <span style="font-weight: bold; font-style: italic;">PP</span>=<span style="font-style: italic;">"| percol | xargs "</span>
alias -g <span style="font-weight: bold; font-style: italic;">W5</span>=<span style="font-style: italic;">"watch -n5 "</span>
alias -g <span style="font-weight: bold; font-style: italic;">W1</span>=<span style="font-style: italic;">"watch -n1 "</span>


alias -g <span style="font-weight: bold; font-style: italic;">CB</span>=<span style="font-style: italic;">"| col -b "</span>
alias -g <span style="font-weight: bold; font-style: italic;">NC</span>=<span style="font-style: italic;">"| col -b "</span>
alias -g <span style="font-weight: bold; font-style: italic;">U</span>=<span style="font-style: italic;">'| uniq '</span>
alias -g <span style="font-weight: bold; font-style: italic;">XT</span>=<span style="font-style: italic;">'urxvt -e '</span>
alias -g <span style="font-weight: bold; font-style: italic;">DM</span>=<span style="font-style: italic;">'| dmenu '</span>
alias -g <span style="font-weight: bold; font-style: italic;">DMV</span>=<span style="font-style: italic;">'| dmenu -i -l 20 '</span>

alias -g ...=<span style="font-style: italic;">'../..'</span>
alias -g ....=<span style="font-style: italic;">'../../..'</span>
alias -g .....=<span style="font-style: italic;">'../../../..'</span>

alias -g <span style="font-weight: bold; font-style: italic;">l10</span>=<span style="font-style: italic;">'*(om[1,10])'</span>
alias -g <span style="font-weight: bold; font-style: italic;">l20</span>=<span style="font-style: italic;">'*(om[1,20])'</span>
alias -g <span style="font-weight: bold; font-style: italic;">l5</span>=<span style="font-style: italic;">'*(om[1,5])'</span>
alias -g <span style="font-weight: bold; font-style: italic;">l</span>=<span style="font-style: italic;">'*(om[1])'</span>
alias -g <span style="font-style: italic;">'**.'</span>=<span style="font-style: italic;">'**/*(.)'</span>
alias -g <span style="font-weight: bold; font-style: italic;">lpdf</span>=<span style="font-style: italic;">'*.pdf(om[1])'</span>
alias -g <span style="font-weight: bold; font-style: italic;">lpng</span>=<span style="font-style: italic;">'*.png(om[1])'</span>

alias -g <span style="font-weight: bold; font-style: italic;">u</span>=<span style="font-style: italic;">'*(om[1])'</span>

alias <span style="font-weight: bold; font-style: italic;">lsmov</span>=<span style="font-style: italic;">'ls *.(mp4|mpg|mpeg|avi|mkv)'</span>
alias <span style="font-weight: bold; font-style: italic;">lspdf</span>=<span style="font-style: italic;">'ls *.(pdf|djvu)'</span>
alias <span style="font-weight: bold; font-style: italic;">lsmp3</span>=<span style="font-style: italic;">'ls *.mp3'</span>
alias <span style="font-weight: bold; font-style: italic;">lspng</span>=<span style="font-style: italic;">'ls *.png'</span>
</pre>
</div>
<p>
Now, some sequences of words can start making sense:
</p>

<ul class="org-ul">
<li><code>lspdf -tr TL DM XA evince</code></li>
<li><code>docker exec -u root -ti $(docker ps -q H1) bash</code></li>
<li><code>docker ps DM P1 XA docker stop</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgd384428" class="outline-3">
<h3 id="orgd384428"><span class="section-number-3">7.4</span> Autocomplete</h3>
<div class="outline-text-3" id="text-7-4">
<p>
Writting smart autocompletion scripts is not easy.
</p>

<p>
zsh supports <code>compdef _gnu_generic</code> type of completion, which gets
you very far with 0 effort.
</p>

<p>
When autocompleting after a <code>-</code> in the commandline, if your command
is configured like <code>compdef _gnu_generic mycommand</code>, zsh will call
the script with <code>--help</code> and parse the output, trying to find
flags, and will use them as suggestions. It's really great.
</p>

<p>
The compromise is to write a decent "&#x2013;help" for your script. Which
is cool because your user will love it too, and you just have to
write it once.
</p>

<p>
The completion is not context aware though, so you can't
autocomplete flags after the first non-flag argument. It seems this
could be improved in zsh-land, by asking for the &#x2013;help like
<code>mycommand args-so-far --help</code>. But it doesn't work like that.
</p>


<div class="org-src-container">
<pre class="src src-zsh">#!/usr/bin/env bash
# The script can be bash-only, while the completion work in zsh-only
set -Eeuo pipefail

help() {
  echo "  -h,--help    Show help"
  echo "  -c,--command Another thing"
}

if [ "$1" == "--help" ];
  help
fi
</pre>
</div>

<p>
Now you can play with <code>mycommand -&lt;TAB&gt;</code>. Amazing, wow.
</p>
</div>
</div>

<div id="outline-container-org1c2c1fa" class="outline-3">
<h3 id="org1c2c1fa"><span class="section-number-3">7.5</span> Create helpers and generate global aliases automagically</h3>
<div class="outline-text-3" id="text-7-5">
<p>
Borrowing a bit from Perl, a bit from Forth, and a bit from
PicoLisp, I've come to create a few helpers that abstract words
into a bit higher level concepts. Unifying the option selectors is
one, and then, other line oriented operations like <code>chomp, from,
   till</code>.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">pick</span>() {
  <span style="font-weight: bold;">if</span> [ -z <span style="font-style: italic;">"$DISPLAY"</span> ]; <span style="font-weight: bold;">then</span>
    percol || fzf || slmenu -i -l 20
  <span style="font-weight: bold;">else</span>
    dmenu -i -l 20
  <span style="font-weight: bold;">fi</span>
}
alias -g <span style="font-weight: bold; font-style: italic;">P</span>=<span style="font-style: italic;">'| pick'</span>

<span style="font-weight: bold;">globalias</span>() {
  alias -g <span style="font-weight: bold;">`echo -n $1 | tr '[a-z]' '[A-Z]'`</span>=<span style="font-style: italic;">" | $1 "</span>
}

globalias fzf

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">uniquify column</span>
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">uc</span> () {
  awk -F<span style="font-style: italic;">" "</span> <span style="font-style: italic;">"!_[\$$1]++"</span>
}
globalias uc

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">from</span>() { perl -pe <span style="font-style: italic;">"s|.*?$1|\1|"</span> }
globalias from

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">till</span>() { sed -e <span style="font-style: italic;">"s|$1.*|$1|"</span> }
globalias till

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">chomp</span> () { sed -e <span style="font-style: italic;">"s|.$||"</span> }
globalias chomp
</pre>
</div>

<p>
Again, it's a pity those do not compose well. Just be well
organized, or build a more elaborate hack so you can compose
aliases with some sort of confidence. It'll always be a hack
though.
</p>
</div>
</div>
<div id="outline-container-org2533bc9" class="outline-3">
<h3 id="org2533bc9"><span class="section-number-3">7.6</span> suffix aliases don't have to match a filename</h3>
<div class="outline-text-3" id="text-7-6">
<p>
zsh has another type of aliases called "suffix alias". Those alias
allow you to define programs to open/run file types.
</p>
<div class="org-src-container">
<pre class="src src-shell">alias -s <span style="font-weight: bold; font-style: italic;">docx</span>=<span style="font-style: italic;">"libreoffice"</span>
</pre>
</div>

<p>
With this said, if you write a name of a file ending with <code>docx</code> as
the first token in a command line, it will use libreoffice to open
it.
</p>

<div class="org-src-container">
<pre class="src src-shell">invoice1.docx
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">will effectively call libreoffice invoice1.docx</span>
</pre>
</div>

<p>
The trick here is that the parser doesn't check that the file is
indeed an existing file. It can be any string.
</p>

<p>
Let's look at an example of it.
</p>

<div class="org-src-container">
<pre class="src src-shell">alias -s <span style="font-weight: bold; font-style: italic;">git</span>=<span style="font-style: italic;">"git clone"</span>
</pre>
</div>

<p>
In this case, we can easily copy a <code>git@github.com:.....git</code> from a
browser, and paste it into a zsh console. Then, zsh will run that
"file" with the command <code>git clone</code>, effectively cloning that
repository.
</p>

<p>
Cool, ain't it?
</p>
</div>
</div>

<div id="outline-container-org51fd6da" class="outline-3">
<h3 id="org51fd6da"><span class="section-number-3">7.7</span> noglob</h3>
<div class="outline-text-3" id="text-7-7">
<p>
zsh has more aggressive parameter expansion, to the level that
<code>[,],...</code> have special meanings, and will be interpreted and
expanded before calling the final commands in your shell.
</p>

<p>
There are commands that you don't want ever expanded , for example,
when using <code>curl</code>, it's much more likely that an open bracket will
be ment to be there verbatim rather than expanded.
</p>

<p>
Zsh provides a command to quote the following expansions. And it's
called noglob.
</p>
<div class="org-src-container">
<pre class="src src-bash">noglob curl http://example.com<span style="font-style: italic;">\&amp;</span>a[]=1
</pre>
</div>
</div>
</div>

<div id="outline-container-orgae915f4" class="outline-3">
<h3 id="orgae915f4"><span class="section-number-3">7.8</span> make noglob 'transparent' to bash</h3>
<div class="outline-text-3" id="text-7-8">
<p>
zsh and bash are mostly compatible, but there's a few things not
supported in bash. <code>noglob</code> is one of them. To build a cushion
inbetween, an easy way is to just create a <code>~/bin/noglob</code> file
</p>
<div class="org-src-container">
<pre class="src src-bash">$<span style="font-weight: bold; font-style: italic;">*</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc09a3f5" class="outline-3">
<h3 id="orgc09a3f5"><span class="section-number-3">7.9</span> glob nested expansion</h3>
<div class="outline-text-3" id="text-7-9">
<p>
In <a href="https://news.ycombinator.com/item?id=26175894">https://news.ycombinator.com/item?id=26175894</a> there's a nice
advanced example:
</p>

<div class="org-src-container">
<pre class="src src-text">Variable expansion syntax, glob qualifiers, and history modifiers can
be combined/nested quite nicely. For example, this outputs all the
commands available from $PATH: `echo
${~${path/%/\/*(*N:t)}}`. `${~foo}` is to enable glob expansion on the
result of foo. `${foo/%/bar}` substitutes the end of the result of foo
to "bar" (i.e. it appends it); when foo is an array, it does it for
each element. In `/*(*N:t)`, we're adding the slash and star to the
paths from `$path`, then the parentheses are glob qualifiers. `*`
inside means only match the executables, `N` is to activate NULL_GLOB
for the match so that we don't get errors for globs that didn't match
anything, `:t` is a history mod used for globs that returns just the
"tail" of the result, i.e. the basename. IIRC, bash can't even nest
multiple parameter expansions; you need to save each step separately.
</pre>
</div>
</div>
</div>
<div id="outline-container-org627863e" class="outline-3">
<h3 id="org627863e"><span class="section-number-3">7.10</span> Some extra shortcuts for nice things</h3>
<div class="outline-text-3" id="text-7-10">
<ul class="org-ul">
<li><code>alt-'</code> quotes the current line. It's like <code>quotemeta</code>. great to
help you fight double and triple quoting when writing scripts.</li>
<li><code>alt-#</code> comment and accept. Nice way to store the current line
for later.</li>
<li><code>ctrl-o</code> kill-current-line, wait for a command, and paste.</li>
</ul>
</div>
</div>

<div id="outline-container-org99781f2" class="outline-3">
<h3 id="org99781f2"><span class="section-number-3">7.11</span> =()</h3>
<div class="outline-text-3" id="text-7-11">
<p>
Zsh has <code>&lt;()</code> and <code>&gt;()</code> like Bash, but it also has <code>=()</code>. This
varant is similar to <code>&lt;()</code> but instead of creating a temporary
pipe, it creates a temporary file. That is useful if we want to run
commands that require a file instead of a pipe (most times, because
it uses lseek to go through it).
</p>

<p>
Node is an example of this.
</p>
<div class="org-src-container">
<pre class="src src-shell">node &lt;(<span style="font-weight: bold;">echo</span> <span style="font-style: italic;">'setTimeout(() =&gt; console.log("foo"), 400)'</span>)   <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">fails</span>
node =(<span style="font-weight: bold;">echo</span> <span style="font-style: italic;">'setTimeout(() =&gt; console.log("foo"), 400)'</span>)   <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">works!</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga9dc7f7" class="outline-2">
<h2 id="orga9dc7f7"><span class="section-number-2">8</span> <span class="todo TODO">TODO</span> patterns</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org96b5722" class="outline-3">
<h3 id="org96b5722"><span class="section-number-3">8.1</span> just use cat/netcat/pipes with &lt;()</h3>
<div class="outline-text-3" id="text-8-1">
<ul class="org-ul">
<li><p>
input
</p>

<p>
<code>python logger.py executable</code> will run the executable and monitor it
for error messages. Depending on the error messages it will be doing.
</p>

<p>
In order to test it, I want to run it with my own output. So what I
do is <code>python logger.py cat</code>. That way I can type my stuff there,
and even better, I can use a stream from the shell. <code>myexecutable |
  python logger.py cat</code> still works.
</p></li>
</ul>
</div>

<div id="outline-container-orge4166c6" class="outline-4">
<h4 id="orge4166c6"><span class="section-number-4">8.1.1</span> what's the unifying theory behind all that?</h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
It's still not clear to me how they relate, but the feeling is
that there's a common thread ruling all those commands. as if they
generalize over the same things, or just a couple of very
interrelated things.
</p>

<p>
<code>echo</code> is to <code>cat</code> what <code>|</code> is to <code>xargs</code>. and <code>&lt;()</code> and <code>&gt;()</code> are
able to make static files be dynamic streams. putting <code>cat</code> and
<code>echo</code> inside <code>&lt;()</code> seem like either a noop, or a leap in what can
be done there. Still have to figure it out.
</p>

<p>
&lt;(grep a file.txt) , | xargs , cat, echo
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">you-have\it-wants</td>
<td class="org-left">executable</td>
<td class="org-left">file</td>
<td class="org-left">stream</td>
</tr>

<tr>
<td class="org-left">executable</td>
<td class="org-left">X</td>
<td class="org-left">&lt;(exe)</td>
<td class="org-left">exe &vert;</td>
</tr>

<tr>
<td class="org-left">file</td>
<td class="org-left">&lt;(cat file)</td>
<td class="org-left">X</td>
<td class="org-left">cat file &vert;</td>
</tr>

<tr>
<td class="org-left">stream</td>
<td class="org-left">cat</td>
<td class="org-left">&lt;(grep foo file.txt)</td>
<td class="org-left">X</td>
</tr>
</tbody>
</table>


<ul class="org-ul">
<li><p>
output
</p>

<p>
Most of those can be tested with and <code>tee</code>. Sometimes you would like
the output to be an output to a file to be extramassaged.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">you-have\it-wants</td>
<td class="org-left">executable</td>
<td class="org-left">file</td>
<td class="org-left">stream</td>
</tr>

<tr>
<td class="org-left">executable</td>
<td class="org-left">X</td>
<td class="org-left">&gt;()</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">file</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">X</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">stream</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&gt;(cat)</td>
<td class="org-left">X</td>
</tr>
</tbody>
</table>

<p>
lnav &lt;(tail -F /my/logfile-that-gets-rotated-or-truncated.log)
cat &lt;(date)
</p></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc5c31a8" class="outline-3">
<h3 id="orgc5c31a8"><span class="section-number-3">8.2</span> redirects &amp; streams</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li><a href="https://catonmat.net/ftp/bash-redirections-cheat-sheet.pdf">https://catonmat.net/ftp/bash-redirections-cheat-sheet.pdf</a></li>
<li><a href="https://catonmat.net/bash-one-liners-explained-part-three">https://catonmat.net/bash-one-liners-explained-part-three</a></li>
<li><a href="https://github.com/miguelmota/bash-streams-handbook">https://github.com/miguelmota/bash-streams-handbook</a></li>
<li><a href="https://www2.dmst.aueb.gr/dds/sw/dgsh/">https://www2.dmst.aueb.gr/dds/sw/dgsh/</a></li>
</ul>
</div>
</div>
<div id="outline-container-org71610e0" class="outline-3">
<h3 id="org71610e0"><span class="section-number-3">8.3</span> The $0 pattern</h3>
<div class="outline-text-3" id="text-8-3">
<p>
<a href="https://www.reddit.com/r/oilshell/comments/f6of85/four_more_posts_in_shell_the_good_parts/">https://www.reddit.com/r/oilshell/comments/f6of85/four_more_posts_in_shell_the_good_parts/</a>
</p>
</div>
</div>
<div id="outline-container-orgec2a1e4" class="outline-3">
<h3 id="orgec2a1e4"><span class="section-number-3">8.4</span> use git staging area to diff outputs of commands</h3>
<div class="outline-text-3" id="text-8-4">
<p>
<a href="https://chrismorgan.info/blog/make-and-git-diff-test-harness/">https://chrismorgan.info/blog/make-and-git-diff-test-harness/</a>
</p>
</div>
</div>
<div id="outline-container-org451fd08" class="outline-3">
<h3 id="org451fd08"><span class="section-number-3">8.5</span> coprocs</h3>
<div class="outline-text-3" id="text-8-5">
<ul class="org-ul">
<li><a href="https://stackoverflow.com/questions/7942632/how-to-extrace-pg-backend-pid-from-postgresql-in-shell-script-and-pass-it-to-ano/8305578#8305578">https://stackoverflow.com/questions/7942632/how-to-extrace-pg-backend-pid-from-postgresql-in-shell-script-and-pass-it-to-ano/8305578#8305578</a></li>
<li><a href="https://unix.stackexchange.com/questions/86270/how-do-you-use-the-command-coproc-in-various-shells">https://unix.stackexchange.com/questions/86270/how-do-you-use-the-command-coproc-in-various-shells</a></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga3eb7c8" class="outline-2">
<h2 id="orga3eb7c8"><span class="section-number-2">9</span> links</h2>
<div class="outline-text-2" id="text-9">
<ul class="org-ul">
<li><a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html">https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html</a></li>
<li><a href="https://www.gnu.org/software/bash/manual/html_node/">https://www.gnu.org/software/bash/manual/html_node/</a></li>
<li><a href="https://tldp.org/LDP/abs/html/">https://tldp.org/LDP/abs/html/</a></li>
<li><a href="https://mywiki.wooledge.org/BashPitfalls">https://mywiki.wooledge.org/BashPitfalls</a></li>
<li><a href="https://www.youtube.com/watch?v=sCZJblyT_XM">Gary Bernhardt. The Unix Chainsaw</a></li>
<li><a href="https://github.com/spencertipping/">spencertipping@github</a>. This guy has some really sick snippets</li>
<li><a href="https://news.ycombinator.com/item?id=23765123">https://news.ycombinator.com/item?id=23765123</a></li>
<li><a href="https://medium.com/@joydeepubuntu/functional-programming-in-bash-145b6db336b7">https://medium.com/@joydeepubuntu/functional-programming-in-bash-145b6db336b7</a></li>
<li><a href="https://www.youtube.com/watch?v=yD2ekOEP9sU">https://www.youtube.com/watch?v=yD2ekOEP9sU</a></li>
<li><a href="http://catern.com/posts/pipes.html">http://catern.com/posts/pipes.html</a></li>
<li><a href="https://ebzzry.io/en/zsh-tips-1/">https://ebzzry.io/en/zsh-tips-1/</a></li>
<li><a href="https://github.com/ssledz/bash-fun">https://github.com/ssledz/bash-fun</a></li>
<li><a href="https://news.ycombinator.com/item?id=24556022">https://news.ycombinator.com/item?id=24556022</a></li>
<li><a href="https://www.datafix.com.au/BASHing/index.html">https://www.datafix.com.au/BASHing/index.html</a></li>
<li><a href="https://susam.github.io/tucl/the-unix-command-language.html">https://susam.github.io/tucl/the-unix-command-language.html</a></li>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html">https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html</a></li>
<li><a href="https://github.com/dylanaraps/pure-sh-bible">https://github.com/dylanaraps/pure-sh-bible</a></li>
<li><a href="https://shatterealm.netlify.app/programming/2021_01_02_shiv_lets_build_a_vcs">https://shatterealm.netlify.app/programming/2021_01_02_shiv_lets_build_a_vcs</a></li>
<li><a href="https://news.ycombinator.com/item?id=24401085">https://news.ycombinator.com/item?id=24401085</a></li>
<li><a href="https://git.sr.ht/~sircmpwn/shit">https://git.sr.ht/~sircmpwn/shit</a></li>
<li><a href="https://github.com/p8952/bocker">bocker</a>. Docker implemented in around 100 lines of bash.</li>
</ul>
</div>
</div>

<div id="outline-container-org7a15a5c" class="outline-2">
<h2 id="org7a15a5c"><span class="section-number-2">10</span> From shell to lisp and everything in between</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li><a href="https://github.com/oilshell/oil">Oil Shell</a>.</li>
<li><a href="https://rash-lang.org/">Rash</a> (Racket shell)</li>
<li><a href="https://arxiv.org/pdf/2007.09436.pdf">PaSh</a>: Light-touch Data-Parallel Shell Processing.</li>
<li><a href="https://www.eigenbahn.com/2020/07/08/painless-emacs-remote-shells">Painless emacs remote shells</a>. Because emacs has you covered</li>
<li><a href="https://news.ycombinator.com/item?id=24249646">https://news.ycombinator.com/item?id=24249646</a> rust</li>
<li><a href="https://github.com/liljencrantz/crush">https://github.com/liljencrantz/crush</a></li>
<li><a href="https://github.com/artyom-poptsov/metabash">https://github.com/artyom-poptsov/metabash</a></li>
<li><a href="https://www.nushell.sh/">https://www.nushell.sh/</a></li>
<li><a href="https://github.com/borkdude/babashka">Babashka</a></li>
<li>Bash to Perl/Python/Ruby using <code>``</code> and growing from there.</li>
</ul>
</div>
</div>
<div id="outline-container-org735dc96" class="outline-2">
<h2 id="org735dc96"><span class="section-number-2">11</span> Credits</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li>Raimon Grau &lt;<a href="mailto:raimonster@gmail.com">raimonster@gmail.com</a>&gt;.</li>
<li>Some examples are result of Raimon's and Lluís Esquerda's
conversations or real world examples.</li>
<li>people in <a href="https://news.ycombinator.com/item?id=24402571">https://news.ycombinator.com/item?id=24402571</a> which I'll
be pulling in as time allows.</li>
</ul>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="https://gist.github.com/samth/3083053">https://gist.github.com/samth/3083053</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Raimon Grau</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.1 (<a href="https://orgmode.org">Org</a> mode 9.1.9)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
